[{"id":0,"href":"/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E5%9F%BA%E7%A1%80/","title":"Go语言基础","section":"Go基础","content":"\rGo语言基础\r#\r8.26 已完成：\ngo的特点与优势 包管理 实现重载 实现继承 TODO：\n实现多态 切片与数组区别 slice相关 struct与class 错误处理机制 1. 和Java对比，介绍一下go语言的优势和特点\r#\r考点：对编程语言的理解\n难度：简单\n总的来说，Go语言在性能、并发处理、部署和开发效率上都有其独特的优势，尤其适合网络服务和云计算领域\n语法简洁：Go语言的语法非常简洁，没有类和继承等概念，代码易于维护和读写 编译型语言：Go语言是一种编译型语言，编译成机器码直接运行，且编译速度很快 高性能：Go语言的执行速度接近于C/C++，速度比Java快 并发支持：Go语言的并发模型是基于goroutine和channel，使得并发编程变的简单高效，而Java的多线程模型相对较为复杂一些 内存管理：Go语言拥有自己的垃圾回收机制，简化了内存管理 部署简单：Go程序编译后生成单一的可执行文件，部署非常简单 标准库丰富：Go拥有高质量的标准库，涵盖网络、加密、数据结构等方面 工具链：Go有一套强大的工具链，如用于格式化代码的gofmt、用于性能分析的pprof 静态类型：Go是静态类型语言，有助于在编译时捕捉错误 跨平台编译：Go支持跨平台编译，可以很方便地为不同操作系统构建应用程序 2. go包管理的方式有哪些？\r#\r考点：包管理\n难度：简单\nGo语言的包管理最开始是GOPATH的方式，每个项目都需要放在GOPATH的下面，Go会从GOPATH的src目录寻找所有的包。\n现在主要用Go Modules，官方从1.11版本开始引入，成了官方推荐的包管理方式。不再依赖GOPATH,可以直接在任何地方创建项目，通过go.mod文件来管理依赖。\n3. Go支持重载吗？如何在Go中实现一个方法的\u0026quot;重载\u0026quot;？\r#\r考点：方法重载\n难度：中等\nGo 不支持函数/方法的重载，你不能在同一个作用域中定义多个函数名相同但参数不同的函数\n会报编译错误：“（function name） redeclared in this block”。\n可以通过以下方式模拟：\n使用接口+类型断言 func Add(a,b interface{}) interface{} { switch aVal := a.(type) { case int: if bVal,ok:=b.(int);ok{ return aVal+bVal } case float64: if bVal,ok:=b.(float64);ok{ return aVal+bVal } } return nil } 使用组合+接口 不同的方法封装在不同的嵌套结构中，外部选择性调用这些方法\n// 定义包含不同方法的结构体 type StringPrinter struct{} func (p StringPrinter) Print(s string) { fmt.Println(\u0026#34;String:\u0026#34;, s) } type IntPrinter struct{} func (p IntPrinter) Print(n int) { fmt.Println(\u0026#34;Int:\u0026#34;, n) } // 组合成一个“统一接口” type Printer struct { StringPrinter IntPrinter } // func main() { p := Printer{} p.Print(\u0026#34;hello\u0026#34;) // 调用 StringPrinter.Print p.Print(42) // 调用 IntPrinter.Print } 使用范型（1.18版本后） func Add[T int | float64](a,b T) T { return a+b } fmt.Println(Add(1, 2)) // 3 fmt.Println(Add(1.1, 2.2)) // 3.3 泛型是 Go 实现“重载”的最佳选择，因为它是类型安全的，且有编译时检查\n拓展回答：\n什么是类型安全？ 程序中的变量只能用于其所属类型允许的操作，不允许发生不合理的类型转换或操作。\n好处 说明 防止错误 避免对类型使用不合法的操作（如把字符串当成数字） 提高可读性 变量类型明确，代码更清晰 增强 IDE 智能提示 自动补全和类型跳转依赖类型信息 更好的性能优化 编译器可以做更激进的优化（例如内联、分配优化等） 什么是编译时检查？ 编译器在代码编译阶段就会检查语法、类型、常量表达式、未使用变量等错误。\n静态类型与编译时检查 静态类型语言中，变量的类型在编译时就确定，不能随意更改。动态类型语言中，变量的类型在运行时才决定，变量可以赋不同类型的值。\n如果语言是静态类型的，通常就支持编译时类型检查； 如果语言是动态类型的，通常类型检查只能在运行时进行 重写（overriding）在 OOP 领域中是指子类重写父类的方法，在 go 中称为方法的覆盖（当一个嵌套结构体（被组合的 struct）和外部结构体拥有相同方法名时，外部的方法会覆盖嵌套结构体的方法。）\n4. Go语言中如何实现继承？\r#\r考点：面向对象编程\n难度：中等\nGo 语言中并没有传统的继承机制（如 Java 的 extends 或 C++ 的基类继承），而是通过**组合（Composition）**实现类似继承的功能。这种方式符合 Go 的设计哲学：优先使用组合，而非继承。\n以下是实现继承的方式及相关说明：\n1. 嵌套结构体实现“继承”\n在 Go 中，结构体可以将另一个结构体嵌套为自己的字段，从而实现类似继承的行为。嵌套结构体中的字段和方法会被提升到外部结构体中，可以直接访问和调用。\n示例：\npackage main import \u0026#34;fmt\u0026#34; // 父结构体 type Animal struct { Name string } func (a Animal) Speak() { fmt.Println(a.Name, \u0026#34;is making a sound\u0026#34;) } // 子结构体 type Dog struct { Animal // 嵌套 Animal，相当于继承 Breed string } func main() { dog := Dog{ Animal: Animal{Name: \u0026#34;Buddy\u0026#34;}, Breed: \u0026#34;Golden Retriever\u0026#34;, } dog.Speak() // 调用嵌套结构体的方法 fmt.Println(dog.Name, \u0026#34;is a\u0026#34;, dog.Breed) } 输出：\nBuddy is making a sound Buddy is a Golden Retriever\n特点：\n通过嵌套结构体实现了方法和字段的复用。 Dog 结构体直接“继承”了 Animal 的字段 Name 和方法 Speak。 2. 方法重写\n子结构体可以定义与父结构体相同的方法，从而覆盖嵌套结构体的方法，实现类似方法重写的功能。\n示例：\nfunc (d Dog) Speak() { fmt.Println(d.Name, \u0026#34;is barking\u0026#34;) } func main() { dog := Dog{ Animal: Animal{Name: \u0026#34;Buddy\u0026#34;}, Breed: \u0026#34;Golden Retriever\u0026#34;, } dog.Speak() // 调用 Dog 的 Speak 方法，而非 Animal 的 } 输出：\nBuddy is barking\n特点：\nDog 的 Speak 方法覆盖了 Animal 的 Speak 方法。 如果需要调用被覆盖的方法，可以显式调用嵌套结构体的方法，例如 dog.Animal.Speak()。 3. 接口与组合的结合\nGo 的接口配合组合机制，可以实现类似继承的多态功能。\n示例：\ntype Speaker interface { Speak() } type Animal struct { Name string } func (a Animal) Speak() { fmt.Println(a.Name, \u0026#34;is making a sound\u0026#34;) } type Dog struct { Animal } func (d Dog) Speak() { fmt.Println(d.Name, \u0026#34;is barking\u0026#34;) } func makeSound(s Speaker) { s.Speak() } func main() { a := Animal{Name: \u0026#34;Generic Animal\u0026#34;} d := Dog{Animal: Animal{Name: \u0026#34;Buddy\u0026#34;}} makeSound(a) // 调用 Animal 的 Speak makeSound(d) // 调用 Dog 的 Speak } 输出：\nGeneric Animal is making a sound Buddy is barking\n特点：\n通过接口定义行为（如 Speak 方法）。 子结构体通过组合和接口实现多态行为。 4. 匿名组合（匿名字段）与字段提升\n当一个结构体嵌套另一个结构体时，如果嵌套的是匿名字段，那么嵌套结构体的字段和方法会被“提升”为外部结构体的字段和方法。\n示例：\ntype Address struct { City, State string } type Person struct { Name string Address // 匿名字段 } func main() { p := Person{ Name: \u0026#34;Alice\u0026#34;, Address: Address{City: \u0026#34;San Francisco\u0026#34;, State: \u0026#34;CA\u0026#34;}, } fmt.Println(p.Name, \u0026#34;lives in\u0026#34;, p.City, p.State) // Address 的字段被提升 } 输出：\nAlice lives in San Francisco CA\n特点：\nPerson 结构体直接访问 Address 的字段 City 和 State，表现得像继承。 5. 区别于传统继承\n虽然 Go 的组合机制和传统继承类似，但它并不支持：\n访问控制：没有 protected 关键字，所有嵌套字段和方法的访问权限取决于其首字母是否大写。 强制的父子关系：嵌套结构体是组合关系，而不是严格的父子继承关系。 多级继承：嵌套的组合机制更简单，不涉及复杂的继承层级。 6. 使用场景\nGo 的组合机制更倾向于灵活复用，通常会在以下场景中使用：\n复用代码：通过嵌套结构体共享字段和方法。 实现多态：通过接口和组合模拟继承行为。 解耦设计：避免传统继承带来的强耦合问题。 总结\nGo 不支持传统的继承，但可以通过 结构体嵌套 和 接口 实现类似的功能。 组合机制更加灵活，减少了传统继承中的复杂性和层级耦合。 Go 的设计哲学是通过组合和接口实现代码复用，而不是依赖复杂的继承体系。 "},{"id":1,"href":"/%E8%AE%A1%E7%BD%91/%E5%9F%BA%E7%A1%80%E7%AF%87/tcp_ip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E5%B1%82/","title":"TCP/IP网络模型有哪几层？","section":"基础篇","content":"\rTCP/IP网络模型有哪几层？\r#\r1. 应用层\r#\r最上层的，也是我们能直接接触到的就是应用层（Application Layer）,应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。应用层是不用去关心数据是如何传输的,应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。\n2. 传输层\r#\r应用层的数据包会传给传输层，传输层（Transport Layer）是为应用层提供网络支持的。\nflowchart BT\r传输层--\u0026gt;应用层A\r传输层--\u0026gt;应用层B\r在传输层会有两个传输协议，分别是 TCP和 UDP。\nTCP 的全称叫传输控制协议,TCP比UDP多了很多特性，比如流量控制，超时重传，拥塞控制等,这些都是为了保证数据包能可靠的传输给对方。\nUDP相对来说很简单，简单到只负责发送数据包，不保证数据包能抵达对方，但他的实时性相对更好，传输效率也高\n当传输层的数据包大小超过MSS(TCP 最大报文段长度)，就需要将数据包分块，这样即使中途有一个分块丢失或者损坏，只需要重新发送这一个分块，而不需要发送整个数据包。在TCP协议中，我们把每个分块成为一个TCP段\n端口：当设备作为接收方时，传输层则要负责把数据包传给应用，但一台设备可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用去分开来，这个编号就是端口。\n由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。\n3. 网络层\r#\rflowchart BT\r网络层--\u0026gt;传输层A--\u0026gt;应用层A\r网络层--\u0026gt;传输层B--\u0026gt;应用层B\r网络层最常使用的时IP协议，IP协议会将传输层的报文作为数据部分，再加上IP报头组成IP报文，如果IP报文大小超过MTU（以太网中一般为1500字节）就会再次进行分片，得到一个即将发送到网络的IP报文。\n网络层负责将数据从一个设备传输到另一个设备。\n需要将 IP 地址分成两种意义：\n一个是网络号，负责标识该 IP 地址是属于哪个「子网」的； 一个是主机号，负责标识同一「子网」下的不同主机； 这需要配合子网掩码才能算出 IP 地址 的网络号和主机号。\n将IP地址与子网掩码按位与运算，就可以得到网络号。\n将子网掩码取反后与IP地址进行进行按位与运算，就可以得到主机号。\n在寻址的过程中，先匹配到相同的网络号（表示要找到同一个子网），才会去找对应的主机。\n除了寻址能力， IP 协议还有另一个重要的能力就是路由。\n路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。\n所以，IP协议的寻址作用是告诉我们去往下一个目的地该往哪个方向走，路由则是根据下一个目的地选择路径。寻址更像在导航，路由更像在操作方向盘。\n4. 网络接口层\r#\r生成了 IP 头部之后，接下来要交给网络接口层,在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。\nflowchart BT\r网络接口层--\u0026gt;网络层A--\u0026gt;传输层A--\u0026gt;应用层A\r网络接口层--\u0026gt;网络层B--\u0026gt;传输层B--\u0026gt;应用层B\r网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。\n总结\r#\r综上所述，TCP/IP 网络通常是由上到下分成 4 层，分别是应用层，传输层，网络层和网络接口层。\nflowchart BT\r以太网--\u0026gt;网络接口层A--\u0026gt;网络层A--\u0026gt;传输层A--\u0026gt;应用层A\r以太网--\u0026gt;网络接口层B--\u0026gt;网络层B--\u0026gt;传输层B--\u0026gt;应用层B\r"},{"id":2,"href":"/%E8%AE%A1%E7%BD%91/tcp%E7%AF%87/tcp%E7%AF%87/","title":"TCP篇","section":"TCP篇","content":"\rUDP与TCP协议\r#\rUDP协议\r#\rUDP（User Datagram Protocol，用户数据报协议）是一种无连接的传输层协议，它不保证数据可靠到达，也不保证数据顺序到达。它只提供一种简单的面向数据报的通信方式。\n"},{"id":3,"href":"/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%8B%9F%E6%A0%88/","title":"Go语言中栈的实现：Slice还是List？","section":"Go基础","content":"\rGo语言中栈的实现：Slice还是List？\r#\r前言\r#\r在刷 LeetCode 题目「\rLC1047. 删除字符串中的所有相邻重复项」时，我遇到了一个典型的栈应用场景。基于之前的学习，我首先使用 Go 的 container/list（双向链表）来模拟栈，但发现执行效率并不理想。 在查阅了执行速度更快的解法后，我发现大家普遍使用 切片 (slice) 来模拟栈。这引发了我的思考：在 Go 语言中，实现栈时应该用 container/list 还是切片？本文将探讨这两种方式的差异与优劣。\n两种实现方式的底层原理\r#\r为了理解它们的差异，我们首先要了解两者在内存中的样子。\n1. 切片 (Slice) - 连续的盒子 📦\r#\r切片 (slice) 的本质是一个动态数组，它的数据存放在一块连续的内存中。就像一个有格子的长条盒子，所有元素都紧密地挨在一起。\n// --- 用切片实现栈 --- var stack = []byte{} // 入栈 stack = append(stack, \u0026#39;a\u0026#39;) // 出栈 stack = stack[:len(stack)-1] 2. container/list - 分散的车厢 🚂\r#\rcontainer/list 的本质是一个双向链表。它的每个元素（节点）都是一个独立的对象，存放在内存中可能不连续的位置，通过指针相互连接。就像一串火车车厢，每个车厢都知道它的前后车厢是谁。\n// --- 用 list 实现栈 --- stackList := list.New() // 入栈 stackList.PushBack(\u0026#39;a\u0026#39;) // 出栈 stackList.Remove(stackList.Back()) 核心对比：性能与简洁度\r#\r性能对比：为何切片通常更快？\r#\r理论上，两种方式的入栈和出栈操作时间复杂度都是 O(1)。但在实际运行中，切片通常性能更好，这主要得益于“内存局部性”（Memory Locality）。\n切片：由于内存连续，CPU在访问栈顶元素时，可以把邻近的数据也预加载到高速缓存中。这使得连续的push和pop操作命中缓存的概率极高，速度飞快。 list：由于节点在内存中是分散的，CPU访问一个节点后，需要通过指针跳转到下一个，这容易导致“缓存未命中”（Cache Miss），从而降低了执行效率。 代码对比：为何切片更地道？\r#\r从代码风格上看，使用切片更符合Go社区的习惯，代码也更简洁。\n切片的操作是语言内置的，语法直接明了。而 container/list 则需要通过调用一系列方法来完成，代码显得稍长，可读性略逊一筹。\n结论：优先使用切片\r#\r综上所述，我们可以得出一个清晰的结论：\n性能: 切片因其连续的内存布局，通常比list更快。 简洁度: 切片的代码更短小，更符合Go的编程风格。 因此，在Go里遇到栈相关的问题，除非有特殊需求，否则应优先使用切片来模拟。这是最常见也是最高效的做法。\n唯一的例外是，当你需要的不仅仅是一个栈，而是一个需要在中间频繁插入或删除元素的数据结构时，container/list的优势才能体现出来。但对于纯粹的栈操作，切片是毫无疑问的更优选。\n"},{"id":4,"href":"/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E8%AF%AD%E8%A8%80%E5%A0%86/","title":"Go 语言解「前 K 个高频元素」：从排序到堆的深度探索","section":"Go基础","content":"\r前言\r#\r最近在刷 LeetCode 时，遇到了一道非常经典的题目：「\r347. 前 K 个高频元素」。这道题不仅考察了基本的数据处理能力，更引出了一些关于排序和更高级数据结构的深度思考。\n我的第一反应是，这需要分两步走：\n统计每个元素出现的频率。 找出频率最高的 k 个元素。 第一步用哈希表（map）解决非常直观，但第二步“如何找出最高频的k个”则引出了几种不同的实现方式和性能考量。这篇博客记录了我从最直观的“排序”解法，到更高效的“堆”解法的完整思考过程。\n思路一：哈希表 + 排序 (直观解法)\r#\r这是我最先想到的方法，思路清晰，容易理解。\n核心思路\r#\r统计频率：遍历一遍数组，用一个 map[int]int 来存储每个数字及其出现的次数。 转换结构：将 map 中的键值对转换到一个结构体切片中，每个结构体包含 Number 和 Count 两个字段。 排序：对该切片按照 Count 字段进行降序排序。 取值：取出排序后切片的前 k 个元素，即为所求。 实现难点：Go 的自定义排序 sort.Slice\r#\r在第三步中，我们需要对一个自定义的结构体切片进行排序。Go 的 sort 包提供了一个非常强大的函数 sort.Slice，它允许我们提供一个自定义的“比较函数”来定义排序规则。\n对于降序排序，我们的规则是：如果元素 i 的次数大于元素 j 的次数，那么 i 就应该排在 j 的前面。这个规则就通过Less函数告诉sort.Slice。\nGo 代码实现\r#\rimport \u0026#34;sort\u0026#34; func topKFrequent_Sort(nums []int, k int) []int { // 1. 统计频率 freqMap := make(map[int]int) for _, num := range nums { freqMap[num]++ } // 2. 将 map 转换为 struct 切片 type Pair struct { Number int Count int } var pairs []Pair for num, count := range freqMap { pairs = append(pairs, Pair{Number: num, Count: count}) } // 3. 使用 sort.Slice 进行自定义降序排序 sort.Slice(pairs, func(i, j int) bool { return pairs[i].Count \u0026gt; pairs[j].Count }) // 4. 取出前 k 个元素 var result []int for i := 0; i \u0026lt; k; i++ { result = append(result, pairs[i].Number) } return result } 这个解法的时间复杂度是 O(N log N)，瓶颈在于排序。虽然可行，但在面试中，面试官往往会追问：“还有没有更优的方法？”\n思路二：哈希表 + 最小堆 (进阶解法)\r#\r为了优化时间复杂度，我们需要一种比完整排序更高效的方法来“筛选”出前 k 个元素。这正是堆（Heap），也叫**优先队列（Priority Queue）**大显身手的地方。\n核心思路\r#\r这里的思路非常巧妙：我们不维护所有元素，只维护一个大小为 k 的“候选池”。\n统计频率：同上，先用哈希表完成。 维护最小堆：创建一个大小为 k 的最小堆。遍历频率哈希表： 如果堆内元素不足 k 个，直接将当前元素入堆。 如果堆已满，将当前元素的频率与堆顶（也就是堆内频率最小的元素）的频率比较。 如果当前元素频率大于堆顶频率，则将堆顶元素弹出，并将当前元素入堆。 获取结果：遍历完所有元素后，堆里剩下的 k 个元素就是频率最高的 k 个。 这个方法的时间复杂度是 O(N log k)，当 k 远小于 N 时，性能优于排序。\n实现难点：Go 的 container/heap 接口\r#\rGo 的 heap 包提供的是一个接口，我们需要自己定义一个类型，并为它实现Len, Less, Swap, Push, Pop五个方法，来“告诉”heap包如何操作我们的数据。\n最核心的是 Less 方法，对于最小堆，它的规则是 h[i].Count \u0026lt; h[j].Count。 另一个容易混淆的点是 Pop 方法。我们自己写的 Pop 只是简单地移除切片的最后一个元素。而 heap.Pop() 函数在调用它之前，会先把堆顶（索引0）的元素和最后一个元素交换，从而巧妙地实现了“弹出最小值”的效果。 Go 代码实现\r#\rimport \u0026#34;container/heap\u0026#34; // Pair 结构体保持不变 type Pair struct { Number int Count int } // 定义一个最小堆类型 IHeap type IHeap []Pair // 实现 heap.Interface 的五个方法 func (h IHeap) Len() int { return len(h) } func (h IHeap) Less(i, j int) bool { return h[i].Count \u0026lt; h[j].Count } // 最小堆 func (h IHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IHeap) Push(x any) { *h = append(*h, x.(Pair)) } func (h *IHeap) Pop() any { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x } func topKFrequent_Heap(nums []int, k int) []int { // 1. 统计频率 freqMap := make(map[int]int) for _, num := range nums { freqMap[num]++ } // 2. 创建并初始化最小堆 minHeap := \u0026amp;IHeap{} heap.Init(minHeap) // 3. 维护大小为 k 的最小堆 for num, count := range freqMap { heap.Push(minHeap, Pair{Number: num, Count: count}) if minHeap.Len() \u0026gt; k { heap.Pop(minHeap) } } // 4. 收集结果 var result []int for minHeap.Len() \u0026gt; 0 { result = append(result, heap.Pop(minHeap).(Pair).Number) } return result } 总结：sort.Slice vs Heap\r#\r特性 哈希表 + 排序 (sort.Slice) 哈希表 + 堆 (heap) 思路 全部排序后取前 k 个 维护一个大小为 k 的“擂台”进行动态替换 复杂度 O(N log N) O(N log k) 优点 思路直观，代码相对容易理解 性能更优，尤其在 N 很大而 k 较小时 缺点 对所有元素进行了不必要的完整排序 思路和代码实现都更复杂 适用场景 快速实现，数据规模不大 对性能有要求，N 远大于 k 的场景 通过这道题，我不仅学会了两种解决“Top K”问题的核心思路，更重要的是深入理解了 Go 语言中两种高级工具 sort.Slice 和 container/heap 的用法和它们背后的设计思想。这是一次非常有价值的学习经历。\n"},{"id":5,"href":"/%E8%AE%A1%E7%BD%91/tcp%E7%AF%87/test-page/","title":"这是一个测试页面","section":"TCP篇","content":"这是测试页面的内容。\n"}]