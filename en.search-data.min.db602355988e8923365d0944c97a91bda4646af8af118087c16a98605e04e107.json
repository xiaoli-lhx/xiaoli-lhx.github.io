[{"id":0,"href":"/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E5%9F%BA%E7%A1%80/","title":"Go语言基础","section":"Go基础","content":"\rGo语言基础\r#\r8.26 已完成：\ngo的特点与优势 包管理 实现重载 实现继承 TODO：\n实现多态 切片与数组区别 slice相关 struct与class 错误处理机制 1. 和Java对比，介绍一下go语言的优势和特点\r#\r考点：对编程语言的理解\n难度：简单\n总的来说，Go语言在性能、并发处理、部署和开发效率上都有其独特的优势，尤其适合网络服务和云计算领域\n语法简洁：Go语言的语法非常简洁，没有类和继承等概念，代码易于维护和读写 编译型语言：Go语言是一种编译型语言，编译成机器码直接运行，且编译速度很快 高性能：Go语言的执行速度接近于C/C++，速度比Java快 并发支持：Go语言的并发模型是基于goroutine和channel，使得并发编程变的简单高效，而Java的多线程模型相对较为复杂一些 内存管理：Go语言拥有自己的垃圾回收机制，简化了内存管理 部署简单：Go程序编译后生成单一的可执行文件，部署非常简单 标准库丰富：Go拥有高质量的标准库，涵盖网络、加密、数据结构等方面 工具链：Go有一套强大的工具链，如用于格式化代码的gofmt、用于性能分析的pprof 静态类型：Go是静态类型语言，有助于在编译时捕捉错误 跨平台编译：Go支持跨平台编译，可以很方便地为不同操作系统构建应用程序 2. go包管理的方式有哪些？\r#\r考点：包管理\n难度：简单\nGo语言的包管理最开始是GOPATH的方式，每个项目都需要放在GOPATH的下面，Go会从GOPATH的src目录寻找所有的包。\n现在主要用Go Modules，官方从1.11版本开始引入，成了官方推荐的包管理方式。不再依赖GOPATH,可以直接在任何地方创建项目，通过go.mod文件来管理依赖。\n3. Go支持重载吗？如何在Go中实现一个方法的\u0026quot;重载\u0026quot;？\r#\r考点：方法重载\n难度：中等\nGo 不支持函数/方法的重载，你不能在同一个作用域中定义多个函数名相同但参数不同的函数\n会报编译错误：“（function name） redeclared in this block”。\n可以通过以下方式模拟：\n使用接口+类型断言 func Add(a,b interface{}) interface{} { switch aVal := a.(type) { case int: if bVal,ok:=b.(int);ok{ return aVal+bVal } case float64: if bVal,ok:=b.(float64);ok{ return aVal+bVal } } return nil } 使用组合+接口 不同的方法封装在不同的嵌套结构中，外部选择性调用这些方法\n// 定义包含不同方法的结构体 type StringPrinter struct{} func (p StringPrinter) Print(s string) { fmt.Println(\u0026#34;String:\u0026#34;, s) } type IntPrinter struct{} func (p IntPrinter) Print(n int) { fmt.Println(\u0026#34;Int:\u0026#34;, n) } // 组合成一个“统一接口” type Printer struct { StringPrinter IntPrinter } // func main() { p := Printer{} p.Print(\u0026#34;hello\u0026#34;) // 调用 StringPrinter.Print p.Print(42) // 调用 IntPrinter.Print } 使用范型（1.18版本后） func Add[T int | float64](a,b T) T { return a+b } fmt.Println(Add(1, 2)) // 3 fmt.Println(Add(1.1, 2.2)) // 3.3 泛型是 Go 实现“重载”的最佳选择，因为它是类型安全的，且有编译时检查\n拓展回答：\n什么是类型安全？ 程序中的变量只能用于其所属类型允许的操作，不允许发生不合理的类型转换或操作。\n好处 说明 防止错误 避免对类型使用不合法的操作（如把字符串当成数字） 提高可读性 变量类型明确，代码更清晰 增强 IDE 智能提示 自动补全和类型跳转依赖类型信息 更好的性能优化 编译器可以做更激进的优化（例如内联、分配优化等） 什么是编译时检查？ 编译器在代码编译阶段就会检查语法、类型、常量表达式、未使用变量等错误。\n静态类型与编译时检查 静态类型语言中，变量的类型在编译时就确定，不能随意更改。动态类型语言中，变量的类型在运行时才决定，变量可以赋不同类型的值。\n如果语言是静态类型的，通常就支持编译时类型检查； 如果语言是动态类型的，通常类型检查只能在运行时进行 重写（overriding）在 OOP 领域中是指子类重写父类的方法，在 go 中称为方法的覆盖（当一个嵌套结构体（被组合的 struct）和外部结构体拥有相同方法名时，外部的方法会覆盖嵌套结构体的方法。）\n4. Go语言中如何实现继承？\r#\r考点：面向对象编程\n难度：中等\nGo 语言中并没有传统的继承机制（如 Java 的 extends 或 C++ 的基类继承），而是通过**组合（Composition）**实现类似继承的功能。这种方式符合 Go 的设计哲学：优先使用组合，而非继承。\n以下是实现继承的方式及相关说明：\n1. 嵌套结构体实现“继承”\n在 Go 中，结构体可以将另一个结构体嵌套为自己的字段，从而实现类似继承的行为。嵌套结构体中的字段和方法会被提升到外部结构体中，可以直接访问和调用。\n示例：\npackage main import \u0026#34;fmt\u0026#34; // 父结构体 type Animal struct { Name string } func (a Animal) Speak() { fmt.Println(a.Name, \u0026#34;is making a sound\u0026#34;) } // 子结构体 type Dog struct { Animal // 嵌套 Animal，相当于继承 Breed string } func main() { dog := Dog{ Animal: Animal{Name: \u0026#34;Buddy\u0026#34;}, Breed: \u0026#34;Golden Retriever\u0026#34;, } dog.Speak() // 调用嵌套结构体的方法 fmt.Println(dog.Name, \u0026#34;is a\u0026#34;, dog.Breed) } 输出：\nBuddy is making a sound Buddy is a Golden Retriever\n特点：\n通过嵌套结构体实现了方法和字段的复用。 Dog 结构体直接“继承”了 Animal 的字段 Name 和方法 Speak。 2. 方法重写\n子结构体可以定义与父结构体相同的方法，从而覆盖嵌套结构体的方法，实现类似方法重写的功能。\n示例：\nfunc (d Dog) Speak() { fmt.Println(d.Name, \u0026#34;is barking\u0026#34;) } func main() { dog := Dog{ Animal: Animal{Name: \u0026#34;Buddy\u0026#34;}, Breed: \u0026#34;Golden Retriever\u0026#34;, } dog.Speak() // 调用 Dog 的 Speak 方法，而非 Animal 的 } 输出：\nBuddy is barking\n特点：\nDog 的 Speak 方法覆盖了 Animal 的 Speak 方法。 如果需要调用被覆盖的方法，可以显式调用嵌套结构体的方法，例如 dog.Animal.Speak()。 3. 接口与组合的结合\nGo 的接口配合组合机制，可以实现类似继承的多态功能。\n示例：\ntype Speaker interface { Speak() } type Animal struct { Name string } func (a Animal) Speak() { fmt.Println(a.Name, \u0026#34;is making a sound\u0026#34;) } type Dog struct { Animal } func (d Dog) Speak() { fmt.Println(d.Name, \u0026#34;is barking\u0026#34;) } func makeSound(s Speaker) { s.Speak() } func main() { a := Animal{Name: \u0026#34;Generic Animal\u0026#34;} d := Dog{Animal: Animal{Name: \u0026#34;Buddy\u0026#34;}} makeSound(a) // 调用 Animal 的 Speak makeSound(d) // 调用 Dog 的 Speak } 输出：\nGeneric Animal is making a sound Buddy is barking\n特点：\n通过接口定义行为（如 Speak 方法）。 子结构体通过组合和接口实现多态行为。 4. 匿名组合（匿名字段）与字段提升\n当一个结构体嵌套另一个结构体时，如果嵌套的是匿名字段，那么嵌套结构体的字段和方法会被“提升”为外部结构体的字段和方法。\n示例：\ntype Address struct { City, State string } type Person struct { Name string Address // 匿名字段 } func main() { p := Person{ Name: \u0026#34;Alice\u0026#34;, Address: Address{City: \u0026#34;San Francisco\u0026#34;, State: \u0026#34;CA\u0026#34;}, } fmt.Println(p.Name, \u0026#34;lives in\u0026#34;, p.City, p.State) // Address 的字段被提升 } 输出：\nAlice lives in San Francisco CA\n特点：\nPerson 结构体直接访问 Address 的字段 City 和 State，表现得像继承。 5. 区别于传统继承\n虽然 Go 的组合机制和传统继承类似，但它并不支持：\n访问控制：没有 protected 关键字，所有嵌套字段和方法的访问权限取决于其首字母是否大写。 强制的父子关系：嵌套结构体是组合关系，而不是严格的父子继承关系。 多级继承：嵌套的组合机制更简单，不涉及复杂的继承层级。 6. 使用场景\nGo 的组合机制更倾向于灵活复用，通常会在以下场景中使用：\n复用代码：通过嵌套结构体共享字段和方法。 实现多态：通过接口和组合模拟继承行为。 解耦设计：避免传统继承带来的强耦合问题。 总结\nGo 不支持传统的继承，但可以通过 结构体嵌套 和 接口 实现类似的功能。 组合机制更加灵活，减少了传统继承中的复杂性和层级耦合。 Go 的设计哲学是通过组合和接口实现代码复用，而不是依赖复杂的继承体系。 "},{"id":1,"href":"/%E8%AE%A1%E7%BD%91/%E5%9F%BA%E7%A1%80%E7%AF%87/tcp_ip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E5%B1%82/","title":"TCP/IP网络模型有哪几层？","section":"基础篇","content":"\rTCP/IP网络模型有哪几层？\r#\r1. 应用层\r#\r最上层的，也是我们能直接接触到的就是应用层（Application Layer）,应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。应用层是不用去关心数据是如何传输的,应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。\n2. 传输层\r#\r应用层的数据包会传给传输层，传输层（Transport Layer）是为应用层提供网络支持的。\nflowchart BT\r传输层--\u0026gt;应用层A\r传输层--\u0026gt;应用层B\r在传输层会有两个传输协议，分别是 TCP和 UDP。\nTCP 的全称叫传输控制协议,TCP比UDP多了很多特性，比如流量控制，超时重传，拥塞控制等,这些都是为了保证数据包能可靠的传输给对方。\nUDP相对来说很简单，简单到只负责发送数据包，不保证数据包能抵达对方，但他的实时性相对更好，传输效率也高\n当传输层的数据包大小超过MSS(TCP 最大报文段长度)，就需要将数据包分块，这样即使中途有一个分块丢失或者损坏，只需要重新发送这一个分块，而不需要发送整个数据包。在TCP协议中，我们把每个分块成为一个TCP段\n端口：当设备作为接收方时，传输层则要负责把数据包传给应用，但一台设备可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用去分开来，这个编号就是端口。\n由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。\n3. 网络层\r#\rflowchart BT\r网络层--\u0026gt;传输层A--\u0026gt;应用层A\r网络层--\u0026gt;传输层B--\u0026gt;应用层B\r网络层最常使用的时IP协议，IP协议会将传输层的报文作为数据部分，再加上IP报头组成IP报文，如果IP报文大小超过MTU（以太网中一般为1500字节）就会再次进行分片，得到一个即将发送到网络的IP报文。\n网络层负责将数据从一个设备传输到另一个设备。\n需要将 IP 地址分成两种意义：\n一个是网络号，负责标识该 IP 地址是属于哪个「子网」的； 一个是主机号，负责标识同一「子网」下的不同主机； 这需要配合子网掩码才能算出 IP 地址 的网络号和主机号。\n将IP地址与子网掩码按位与运算，就可以得到网络号。\n将子网掩码取反后与IP地址进行进行按位与运算，就可以得到主机号。\n在寻址的过程中，先匹配到相同的网络号（表示要找到同一个子网），才会去找对应的主机。\n除了寻址能力， IP 协议还有另一个重要的能力就是路由。\n路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。\n所以，IP协议的寻址作用是告诉我们去往下一个目的地该往哪个方向走，路由则是根据下一个目的地选择路径。寻址更像在导航，路由更像在操作方向盘。\n4. 网络接口层\r#\r生成了 IP 头部之后，接下来要交给网络接口层,在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。\nflowchart BT\r网络接口层--\u0026gt;网络层A--\u0026gt;传输层A--\u0026gt;应用层A\r网络接口层--\u0026gt;网络层B--\u0026gt;传输层B--\u0026gt;应用层B\r网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。\n总结\r#\r综上所述，TCP/IP 网络通常是由上到下分成 4 层，分别是应用层，传输层，网络层和网络接口层。\nflowchart BT\r以太网--\u0026gt;网络接口层A--\u0026gt;网络层A--\u0026gt;传输层A--\u0026gt;应用层A\r以太网--\u0026gt;网络接口层B--\u0026gt;网络层B--\u0026gt;传输层B--\u0026gt;应用层B\r"},{"id":2,"href":"/%E8%AE%A1%E7%BD%91/tcp%E7%AF%87/tcp%E7%AF%87/","title":"TCP篇","section":"TCP篇","content":"\rUDP与TCP协议\r#\rUDP协议\r#\rUDP（User Datagram Protocol，用户数据报协议）是一种无连接的传输层协议，它不保证数据可靠到达，也不保证数据顺序到达。它只提供一种简单的面向数据报的通信方式。\n"}]