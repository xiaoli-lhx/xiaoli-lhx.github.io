<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  Go string 和 []byte 的区别
  
  #
  

如果需要频繁地修改字符串内容，或者处理⼆进制数据，使用[]byte更为合适，如果字符串内容基本保持不变，并且主要处理⽂本数据，那么使⽤  string 更为⽅便。

不可变性

string是不可变的数据类型，一旦创建就不能被修改。任何修改string的操作都会产生一个新的string，而原始的string保持不变。相比之下，[]byte是可变的切片，可以通过索引直接修改切片中的元素

类型转换

可以在string和[]byte之间进行类型转换。使用[]byte(s)可以将string转换为[]byte,而使用string(b)可以将[]byte转换为string。这个操作会创建新的底层数组，因此在转换后修改其中一个不会影响另一个。

内存分配


string是一个不可变的视图，底层数据是只读的。string的内存分配和释放由Go运行时管理。
[]byte是一个可变的切片，底层数据是可以修改的。[]byte的内存管理由程序员负责。


Unicode字符

string中的每个元素是一个Unicode字符，而[]byte中的每个元素是一个字节。因此，string可以包含任意字符，而[]byte主要用于处理字节数据。

  make和new的区别
  
  #
  

make和new是两个用于分配内存的内建函数，在使用场景和返回类型上有明显的区别

make用于创建并初始化切片、映射和通道等引用类型。它返回的是被初始化的**非零值（非nil）**的引用类型。

// 创建并初始化切片
slice:=make([]int,5,10)
// 创建并初始化映射
myMap:=make(map[string]int)
// 创建并初始化通道
ch:=make(chan int)

new ⽤于分配值类型的内存，并返回该值类型的指针。它返回的是分配的零值的指针。

// 分配整数类型的内存，并返回指针
ptr :=new(int)
package main
import &#34;fmt&#34;
func main(){
    // 使用make并初始化切片
    slice:=make([]int,5,10)
    fmt.Println(slice) // 输出:[0 0 0 0 0]
    // 使用new分配整数类型的内存，并返回指针
    ptr:=new(int)
    fmt.Println(*ptr)	// 输出0
}
总结：

new只⽤于分配内存，返回⼀个指向地址的指针。它为每个新类型分配⼀⽚内存，初始化为0且返回类型*T的内存地址，它相当于&amp;T{}
make只可⽤于slice,map,channel的初始化,返回的是引用。


  数组和切片的区别
  
  #
  


数组


固定⻓度，在声明数组时，需要指定数组的⻓度，且不能更改。
值类型，当将⼀个数组赋值给另⼀个数组时，会进⾏值拷⻉。这意味着修改⼀个数组的副本不会影响原始数组。
数组的元素在内存中是顺序存储的，分配在⼀块连续的内存区域


切片


切⽚的⻓度可以动态调整，⽽且可以不指定⻓度。
切⽚是引⽤类型，当将⼀个切⽚赋值给另⼀个切⽚时，它们引⽤的是相同的底层数组。修改⼀个切⽚的元素会 影响到其他引⽤该底层数组的切⽚。
切⽚本身不存储元素，⽽是引⽤⼀个底层数组。切⽚的底层数组会在需要时进⾏动态扩展。

// 创建切⽚
slice1 := make([]int, 3, 5)  // ⻓度为3，容量为5的切⽚
slice2 := []int{1, 2, 3}     // 直接初始化切⽚
slice3 := arr1[:]            // 从数组截取切⽚

  切片是如何扩容的
  
  #
  


切⽚的扩容容量是按指数增⻓的。当切⽚的容量不⾜时，Go运⾏时系统会分配⼀个更⼤的底层数组，并将原来的元素拷⻉到新数组中。新数组的⼤⼩通常是原数组的两倍（但并不⼀定严格遵循2倍关系）
在切⽚扩容时，Go运⾏时系统会预估未来的元素增⻓，并提前分配⾜够的空间。这可以减少频繁的内存分配和拷⻉操作。
对于⼩切⽚，扩容时增加的容量可能相对较⼩，避免了内存的过度浪费。⽽对于⼤切⽚，扩容时增加的容量可能较多。



  首先判断，如果新申请容量⼤于2倍的旧容量，最终容量就是新申请的容量">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E7%AF%87%E9%9D%A2%E8%AF%95%E9%A2%98/">
  <meta property="og:site_name" content="Blog">
  <meta property="og:title" content="面试题-go语言基础">
  <meta property="og:description" content="Go string 和 []byte 的区别#如果需要频繁地修改字符串内容，或者处理⼆进制数据，使用[]byte更为合适，如果字符串内容基本保持不变，并且主要处理⽂本数据，那么使⽤ string 更为⽅便。
不可变性 string是不可变的数据类型，一旦创建就不能被修改。任何修改string的操作都会产生一个新的string，而原始的string保持不变。相比之下，[]byte是可变的切片，可以通过索引直接修改切片中的元素
类型转换 可以在string和[]byte之间进行类型转换。使用[]byte(s)可以将string转换为[]byte,而使用string(b)可以将[]byte转换为string。这个操作会创建新的底层数组，因此在转换后修改其中一个不会影响另一个。
内存分配 string是一个不可变的视图，底层数据是只读的。string的内存分配和释放由Go运行时管理。 []byte是一个可变的切片，底层数据是可以修改的。[]byte的内存管理由程序员负责。 Unicode字符 string中的每个元素是一个Unicode字符，而[]byte中的每个元素是一个字节。因此，string可以包含任意字符，而[]byte主要用于处理字节数据。
make和new的区别#make和new是两个用于分配内存的内建函数，在使用场景和返回类型上有明显的区别
make用于创建并初始化切片、映射和通道等引用类型。它返回的是被初始化的**非零值（非nil）**的引用类型。 // 创建并初始化切片 slice:=make([]int,5,10) // 创建并初始化映射 myMap:=make(map[string]int) // 创建并初始化通道 ch:=make(chan int) new ⽤于分配值类型的内存，并返回该值类型的指针。它返回的是分配的零值的指针。 // 分配整数类型的内存，并返回指针 ptr :=new(int) package main import &#34;fmt&#34; func main(){ // 使用make并初始化切片 slice:=make([]int,5,10) fmt.Println(slice) // 输出:[0 0 0 0 0] // 使用new分配整数类型的内存，并返回指针 ptr:=new(int) fmt.Println(*ptr)	// 输出0 } 总结：
new只⽤于分配内存，返回⼀个指向地址的指针。它为每个新类型分配⼀⽚内存，初始化为0且返回类型*T的内存地址，它相当于&amp;T{} make只可⽤于slice,map,channel的初始化,返回的是引用。 数组和切片的区别#数组 固定⻓度，在声明数组时，需要指定数组的⻓度，且不能更改。 值类型，当将⼀个数组赋值给另⼀个数组时，会进⾏值拷⻉。这意味着修改⼀个数组的副本不会影响原始数组。 数组的元素在内存中是顺序存储的，分配在⼀块连续的内存区域 切片 切⽚的⻓度可以动态调整，⽽且可以不指定⻓度。 切⽚是引⽤类型，当将⼀个切⽚赋值给另⼀个切⽚时，它们引⽤的是相同的底层数组。修改⼀个切⽚的元素会 影响到其他引⽤该底层数组的切⽚。 切⽚本身不存储元素，⽽是引⽤⼀个底层数组。切⽚的底层数组会在需要时进⾏动态扩展。 // 创建切⽚ slice1 := make([]int, 3, 5) // ⻓度为3，容量为5的切⽚ slice2 := []int{1, 2, 3} // 直接初始化切⽚ slice3 := arr1[:] // 从数组截取切⽚ 切片是如何扩容的#切⽚的扩容容量是按指数增⻓的。当切⽚的容量不⾜时，Go运⾏时系统会分配⼀个更⼤的底层数组，并将原来的元素拷⻉到新数组中。新数组的⼤⼩通常是原数组的两倍（但并不⼀定严格遵循2倍关系） 在切⽚扩容时，Go运⾏时系统会预估未来的元素增⻓，并提前分配⾜够的空间。这可以减少频繁的内存分配和拷⻉操作。 对于⼩切⽚，扩容时增加的容量可能相对较⼩，避免了内存的过度浪费。⽽对于⼤切⽚，扩容时增加的容量可能较多。 首先判断，如果新申请容量⼤于2倍的旧容量，最终容量就是新申请的容量">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="go语言">
    <meta property="article:published_time" content="2025-09-01T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-09-01T00:00:00+00:00">
<title>面试题-go语言基础 | Blog</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E7%AF%87%E9%9D%A2%E8%AF%95%E9%A2%98/">
<link rel="stylesheet" href="/book.min.ce742184041b67827be505801d71b6b40c09608dfb292033ea54dbbc1d71a174.css" integrity="sha256-znQhhAQbZ4J75QWAHXG2tAwJYI37KSAz6lTbvB1xoXQ=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.218691bdc78cf0966170d96712168f7d59fbb3d00508ae036a7d8419c10791af.js" integrity="sha256-IYaRvceM8JZhcNlnEhaPfVn7s9AFCK4Dan2EGcEHka8=" crossorigin="anonymous"></script>

  <script defer src="/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js" integrity="sha256-b2&#43;Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC&#43;NdcPIvZhzk=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  <link rel="stylesheet" href="/css/custom.css">
</head>
<body dir="ltr" class="book-kind-page book-type-go语言">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    
<aside class="book-menu">
  <div class="book-menu-content">
    
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>Blog</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>













  



  
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-ece2958ce52732215c05ee4fd8e37c4b" class="toggle"  />
    <label for="section-ece2958ce52732215c05ee4fd8e37c4b" class="flex">
      <a role="button" class="flex-auto ">计网</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2998acf51f5f0061bff7de261b935769" class="toggle"  />
    <label for="section-2998acf51f5f0061bff7de261b935769" class="flex">
      <a role="button" class="flex-auto ">基础篇</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/%E8%AE%A1%E7%BD%91/%E5%9F%BA%E7%A1%80%E7%AF%87/tcp_ip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E5%B1%82/" class="">TCP/IP网络模型有哪几层？</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/%E8%AE%A1%E7%BD%91/%E5%9F%BA%E7%A1%80%E7%AF%87/url_about/" class="">在浏览器中输入URL并按下回车之和会发生什么</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-663286454c4cd9ce11659bd2eb980fee" class="toggle"  />
    <label for="section-663286454c4cd9ce11659bd2eb980fee" class="flex">
      <a role="button" class="flex-auto ">TCP篇</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/%E8%AE%A1%E7%BD%91/tcp%E7%AF%87/tcp%E7%AF%87/" class="">TCP篇</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-67b43edca1c269c7246a75d4308d3b1b" class="toggle" checked />
    <label for="section-67b43edca1c269c7246a75d4308d3b1b" class="flex">
      <a role="button" class="flex-auto ">Go语言</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-770547d614dac05a040d1a3ecfcd842c" class="toggle" checked />
    <label for="section-770547d614dac05a040d1a3ecfcd842c" class="flex">
      <a role="button" class="flex-auto ">Go基础</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E5%9F%BA%E7%A1%80/" class="">Go语言基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%8B%9F%E6%A0%88/" class="">Go语言中栈的实现：Slice还是List？</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E8%AF%AD%E8%A8%80%E5%A0%86/" class="">Go 语言解「前 K 个高频元素」：从排序到堆的深度探索</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E7%AF%87%E9%9D%A2%E8%AF%95%E9%A2%98/" class="active">面试题-go语言基础</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-c493bd57058cffd3653c22fc340e06bc" class="toggle"  />
    <label for="section-c493bd57058cffd3653c22fc340e06bc" class="flex">
      <a role="button" class="flex-auto ">AI面试</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/ai%E9%9D%A2%E8%AF%95/gemini0905/" class="">Gemini0905面试总结</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>



  </div>
</aside>
 

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>面试题-go语言基础</h3>

  <label for="toc-control">
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents"></nav>



  </aside>
  
 
      </header>

      <div class="post-meta">
    <span class="post-date">
      <strong>Date:</strong> September 1, 2025
    </span></div>
      
  <article class="markdown book-article"><h1 id="go-string-和-byte-的区别">
  Go string 和 []byte 的区别
  
  <a class="anchor" href="#go-string-%e5%92%8c-byte-%e7%9a%84%e5%8c%ba%e5%88%ab">#</a>
  
</h1>
<p>如果需要频繁地修改字符串内容，或者处理⼆进制数据，使用<code>[]byte</code>更为合适，如果字符串内容基本保持不变，并且主要处理⽂本数据，那么使⽤  <code>string</code> 更为⽅便。</p>
<ol>
<li>不可变性</li>
</ol>
<p><code>string</code>是不可变的数据类型，一旦创建就不能被修改。任何修改<code>string</code>的操作都会产生一个新的<code>string</code>，而原始的<code>string</code>保持不变。相比之下，<code>[]byte</code>是可变的切片，可以通过索引直接修改切片中的元素</p>
<ol start="2">
<li>类型转换</li>
</ol>
<p>可以在<code>string</code>和<code>[]byte</code>之间进行类型转换。使用<code>[]byte(s)</code>可以将<code>string</code>转换为<code>[]byte</code>,而使用<code>string(b)</code>可以将<code>[]byte</code>转换为<code>string</code>。这个操作会创建新的底层数组，因此在转换后修改其中一个不会影响另一个。</p>
<ol start="3">
<li>内存分配</li>
</ol>
<ul>
<li><code>string</code>是一个不可变的视图，底层数据是只读的。<code>string</code>的内存分配和释放由Go运行时管理。</li>
<li><code>[]byte</code>是一个可变的切片，底层数据是可以修改的。<code>[]byte</code>的内存管理由程序员负责。</li>
</ul>
<ol start="4">
<li>Unicode字符</li>
</ol>
<p><code>string</code>中的每个元素是一个Unicode字符，而<code>[]byte</code>中的每个元素是一个字节。因此，<code>string</code>可以包含任意字符，而<code>[]byte</code>主要用于处理字节数据。</p>
<h1 id="make和new的区别">
  make和new的区别
  
  <a class="anchor" href="#make%e5%92%8cnew%e7%9a%84%e5%8c%ba%e5%88%ab">#</a>
  
</h1>
<p><code>make</code>和<code>new</code>是两个用于分配内存的内建函数，在使用场景和返回类型上有明显的区别</p>
<ul>
<li><code>make</code>用于创建并初始化切片、映射和通道等引用类型。它返回的是被初始化的**非零值（非nil）**的引用类型。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 创建并初始化切片</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">slice</span><span style="color:#f92672">:=</span>make([]<span style="color:#66d9ef">int</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建并初始化映射</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">myMap</span><span style="color:#f92672">:=</span>make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建并初始化通道</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ch</span><span style="color:#f92672">:=</span>make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
</span></span></code></pre></div><ul>
<li><code>new</code> ⽤于分配值类型的内存，并返回该值类型的指针。它返回的是分配的<strong>零值</strong>的指针。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 分配整数类型的内存，并返回指针</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ptr</span> <span style="color:#f92672">:=</span>new(<span style="color:#66d9ef">int</span>)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 使用make并初始化切片</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">slice</span><span style="color:#f92672">:=</span>make([]<span style="color:#66d9ef">int</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">slice</span>) <span style="color:#75715e">// 输出:[0 0 0 0 0]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 使用new分配整数类型的内存，并返回指针</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ptr</span><span style="color:#f92672">:=</span>new(<span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">ptr</span>)	<span style="color:#75715e">// 输出0</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>总结：</p>
<ul>
<li><code>new</code>只⽤于分配内存，返回⼀个指向地址的指针。它为每个新类型分配⼀⽚内存，初始化为0且返回类型*T的内存地址，它相当于&amp;T{}</li>
<li><code>make</code>只可⽤于<strong>slice,map,channel</strong>的初始化,返回的是<strong>引用</strong>。</li>
</ul>
<h1 id="数组和切片的区别">
  数组和切片的区别
  
  <a class="anchor" href="#%e6%95%b0%e7%bb%84%e5%92%8c%e5%88%87%e7%89%87%e7%9a%84%e5%8c%ba%e5%88%ab">#</a>
  
</h1>
<ol>
<li>数组</li>
</ol>
<ul>
<li>固定⻓度，在声明数组时，需要指定数组的⻓度，且不能更改。</li>
<li>值类型，当将⼀个数组赋值给另⼀个数组时，会进⾏值拷⻉。这意味着修改⼀个数组的副本不会影响原始数组。</li>
<li>数组的元素在内存中是顺序存储的，分配在⼀块连续的内存区域</li>
</ul>
<ol start="2">
<li>切片</li>
</ol>
<ul>
<li>切⽚的⻓度可以动态调整，⽽且可以不指定⻓度。</li>
<li>切⽚是引⽤类型，当将⼀个切⽚赋值给另⼀个切⽚时，它们引⽤的是相同的底层数组。修改⼀个切⽚的元素会 影响到其他引⽤该底层数组的切⽚。</li>
<li>切⽚本身不存储元素，⽽是引⽤⼀个底层数组。切⽚的底层数组会在需要时进⾏动态扩展。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 创建切⽚</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">slice1</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>)  <span style="color:#75715e">// ⻓度为3，容量为5的切⽚</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">slice2</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}     <span style="color:#75715e">// 直接初始化切⽚</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">slice3</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">arr1</span>[:]            <span style="color:#75715e">// 从数组截取切⽚</span>
</span></span></code></pre></div><h1 id="切片是如何扩容的">
  切片是如何扩容的
  
  <a class="anchor" href="#%e5%88%87%e7%89%87%e6%98%af%e5%a6%82%e4%bd%95%e6%89%a9%e5%ae%b9%e7%9a%84">#</a>
  
</h1>
<ul>
<li>切⽚的扩容容量是按指数增⻓的。当切⽚的容量不⾜时，Go运⾏时系统会分配⼀个更⼤的底层数组，并将原来的元素拷⻉到新数组中。新数组的⼤⼩通常是原数组的两倍（但并不⼀定严格遵循2倍关系）</li>
<li>在切⽚扩容时，Go运⾏时系统会预估未来的元素增⻓，并提前分配⾜够的空间。这可以减少频繁的内存分配和拷⻉操作。</li>
<li>对于⼩切⽚，扩容时增加的容量可能相对较⼩，避免了内存的过度浪费。⽽对于⼤切⽚，扩容时增加的容量可能较多。</li>
</ul>

<blockquote class='book-hint '>
  <p>首先判断，如果新申请容量⼤于2倍的旧容量，最终容量就是新申请的容量</p>
<p>否则判断，如果旧切⽚的⻓度⼩于1024，则最终容量就是旧容量的两倍</p>
<p>否则判断，如果旧切⽚⻓度⼤于等于1024，则最终容量从旧容量开始循环,增加原来的 1/4, 直到最终容量⼤于等于新申请的容量</p>
<p>如果最终容量计算值溢出，则最终容量就是新申请容量</p>
</blockquote><h1 id="扩容前后的slice是样的吗">
  扩容前后的Slice是⼀样的吗
  
  <a class="anchor" href="#%e6%89%a9%e5%ae%b9%e5%89%8d%e5%90%8e%e7%9a%84slice%e6%98%af%e6%a0%b7%e7%9a%84%e5%90%97">#</a>
  
</h1>
<p>如果扩容后的容量仍然能够容纳新元素，系统会尽量在原地进⾏扩容，否则会分配⼀个新的数组，将原有元素复制到新数组中。</p>
<h1 id="go-slice的底层实现">
  go slice的底层实现
  
  <a class="anchor" href="#go-slice%e7%9a%84%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0">#</a>
  
</h1>
<p>切⽚本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引⽤ 底层数组，设定相关属性将数据读写 操作限定在指定的区域内。切⽚本身是⼀ 个只读对象，其⼯作机制类似数组指针的⼀种封装。 主要通过⼀个结构 体来表示，该结构体包含了以下三个字段：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">slice</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">array</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Ponter</span> <span style="color:#75715e">// 指向底层数组的指针</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">len</span> <span style="color:#66d9ef">int</span>	<span style="color:#75715e">// 切片当前的长度</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cap</span> <span style="color:#66d9ef">int</span> <span style="color:#75715e">// 切片的容量</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  



  
  
  
  <div class="flex flex-wrap justify-between">
    <span>
    
      <a href="/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E8%AF%AD%E8%A8%80%E5%A0%86/" class="flex align-center book-icon">
        <img src="/svg/backward.svg" class="book-icon" alt="Previous" title="Go 语言解「前 K 个高频元素」：从排序到堆的深度探索" />
        <span>Go 语言解「前 K 个高频元素」：从排序到堆的深度探索</span>
      </a>
    
    </span>
    <span>
    
      <a href="/ai%E9%9D%A2%E8%AF%95/gemini0905/" class="flex align-center book-icon">
        <span>Gemini0905面试总结</span>
        <img src="/svg/forward.svg" class="book-icon" alt="Next" title="Gemini0905面试总结" />
      </a>
    
    </span>
  </div>
  




  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 
      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    

 
  </main>

  <footer style="text-align: center; padding: 20px 0; margin-top: 40px;">
    <p>Copyright © 2025 LHX. All Rights Reserved.</p>
</footer>
</body>
</html>
















