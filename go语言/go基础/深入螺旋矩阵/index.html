<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  深入螺旋矩阵：从一个“小 Bug”到“完美”解法的思考之旅
  
  #
  


  前言
  
  #
  

“螺旋矩阵”是 LeetCode 上一道非常经典的算法题。它不仅考验我们对二维数组的操作能力，更考验我们对边界条件处理的细致程度。最近在刷这道题时，我写出了一个看似“正确”的解法，却在某些特定测试用例下意外翻车。
这篇文章记录了我从发现一个微小的 Bug，到层层深入分析其根源，再到举一反三，最终将代码优化到近乎完美的全过程。这趟思考之旅让我对“边界”二字有了更深刻的理解。

  最初的尝试：一个看似正确的解法
  
  #
  

我的第一版代码思路非常直接：用 top, bottom, left, right 四个变量定义当前需要遍历的边界，模拟螺旋的四个步骤（左→右, 上→下, 右→左, 下→上），每走完一圈就收缩一圈边界。同时，用一个 num 计数器来确保我们不多不少，正好读取 n*m 个元素。
代码如下：
// 最初的版本 - 看似正确，但有陷阱
func spiralOrder(matrix [][]int) []int {
    n, m := len(matrix), len(matrix[0])
    total := n * m
    top, bottom, left, right := 0, n-1, 0, m-1
    num := 1
    var res []int
    for num &lt;= total {
        // 1.左-&gt;右
        for i := left; i &lt;= right; i&#43;&#43; {
            res = append(res, matrix[top][i])
            num&#43;&#43;
        }
        top&#43;&#43;
        // 2.上-&gt;下
        for i := top; i &lt;= bottom; i&#43;&#43; {
            res = append(res, matrix[i][right])
            num&#43;&#43;
        }
        right--
        // 3.右-&gt;左
        for i := right; i &gt;= left; i-- {
            res = append(res, matrix[bottom][i])
            num&#43;&#43;
        }
        bottom--
        // 4.下-&gt;上
        for i := bottom; i &gt;= top; i-- {
            res = append(res, matrix[i][left])
            num&#43;&#43;
        }
        left&#43;&#43;
    }
    return res
}
这段代码在处理 3x3 这样的方形矩阵时，表现完美。然而，当我用一个 3x4 的矩阵进行测试时，问题暴露了。">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%85%A5%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/">
  <meta property="og:site_name" content="Blog">
  <meta property="og:title" content="深入螺旋矩阵">
  <meta property="og:description" content="深入螺旋矩阵：从一个“小 Bug”到“完美”解法的思考之旅#前言#“螺旋矩阵”是 LeetCode 上一道非常经典的算法题。它不仅考验我们对二维数组的操作能力，更考验我们对边界条件处理的细致程度。最近在刷这道题时，我写出了一个看似“正确”的解法，却在某些特定测试用例下意外翻车。
这篇文章记录了我从发现一个微小的 Bug，到层层深入分析其根源，再到举一反三，最终将代码优化到近乎完美的全过程。这趟思考之旅让我对“边界”二字有了更深刻的理解。
最初的尝试：一个看似正确的解法#我的第一版代码思路非常直接：用 top, bottom, left, right 四个变量定义当前需要遍历的边界，模拟螺旋的四个步骤（左→右, 上→下, 右→左, 下→上），每走完一圈就收缩一圈边界。同时，用一个 num 计数器来确保我们不多不少，正好读取 n*m 个元素。
代码如下：
// 最初的版本 - 看似正确，但有陷阱 func spiralOrder(matrix [][]int) []int { n, m := len(matrix), len(matrix[0]) total := n * m top, bottom, left, right := 0, n-1, 0, m-1 num := 1 var res []int for num &lt;= total { // 1.左-&gt;右 for i := left; i &lt;= right; i&#43;&#43; { res = append(res, matrix[top][i]) num&#43;&#43; } top&#43;&#43; // 2.上-&gt;下 for i := top; i &lt;= bottom; i&#43;&#43; { res = append(res, matrix[i][right]) num&#43;&#43; } right-- // 3.右-&gt;左 for i := right; i &gt;= left; i-- { res = append(res, matrix[bottom][i]) num&#43;&#43; } bottom-- // 4.下-&gt;上 for i := bottom; i &gt;= top; i-- { res = append(res, matrix[i][left]) num&#43;&#43; } left&#43;&#43; } return res } 这段代码在处理 3x3 这样的方形矩阵时，表现完美。然而，当我用一个 3x4 的矩阵进行测试时，问题暴露了。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="go语言">
    <meta property="article:published_time" content="2025-09-15T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-09-15T00:00:00+00:00">
    <meta property="article:tag" content="Go">
    <meta property="article:tag" content="算法">
    <meta property="article:tag" content="数据结构">
    <meta property="article:tag" content="LeetCode">
    <meta property="article:tag" content="螺旋矩阵">
<title>深入螺旋矩阵 | Blog</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%85%A5%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/">
<link rel="stylesheet" href="/book.min.ce742184041b67827be505801d71b6b40c09608dfb292033ea54dbbc1d71a174.css" integrity="sha256-znQhhAQbZ4J75QWAHXG2tAwJYI37KSAz6lTbvB1xoXQ=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.4252892e0f19cc49afbe25b7f2eb0ae35725e8125f94af588825010da864f339.js" integrity="sha256-QlKJLg8ZzEmvviW38usK41cl6BJflK9YiCUBDahk8zk=" crossorigin="anonymous"></script>

  <script defer src="/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js" integrity="sha256-b2&#43;Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC&#43;NdcPIvZhzk=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  <link rel="stylesheet" href="/css/custom.css">
</head>
<body dir="ltr" class="book-kind-page book-type-go语言">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    
<aside class="book-menu">
  <div class="book-menu-content">
    
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>Blog</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>













  



  
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-ece2958ce52732215c05ee4fd8e37c4b" class="toggle"  />
    <label for="section-ece2958ce52732215c05ee4fd8e37c4b" class="flex">
      <a role="button" class="flex-auto ">计网</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2998acf51f5f0061bff7de261b935769" class="toggle"  />
    <label for="section-2998acf51f5f0061bff7de261b935769" class="flex">
      <a role="button" class="flex-auto ">基础篇</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/%E8%AE%A1%E7%BD%91/%E5%9F%BA%E7%A1%80%E7%AF%87/tcp_ip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E5%B1%82/" class="">TCP/IP网络模型有哪几层？</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/%E8%AE%A1%E7%BD%91/%E5%9F%BA%E7%A1%80%E7%AF%87/url_about/" class="">在浏览器中输入URL并按下回车之和会发生什么</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-663286454c4cd9ce11659bd2eb980fee" class="toggle"  />
    <label for="section-663286454c4cd9ce11659bd2eb980fee" class="flex">
      <a role="button" class="flex-auto ">TCP篇</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/%E8%AE%A1%E7%BD%91/tcp%E7%AF%87/tcp%E7%AF%87/" class="">TCP篇</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-67b43edca1c269c7246a75d4308d3b1b" class="toggle" checked />
    <label for="section-67b43edca1c269c7246a75d4308d3b1b" class="flex">
      <a role="button" class="flex-auto ">Go语言</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-770547d614dac05a040d1a3ecfcd842c" class="toggle" checked />
    <label for="section-770547d614dac05a040d1a3ecfcd842c" class="flex">
      <a role="button" class="flex-auto ">Go基础</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E5%9F%BA%E7%A1%80/" class="">Go语言基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%8B%9F%E6%A0%88/" class="">Go语言中栈的实现：Slice还是List？</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E8%AF%AD%E8%A8%80%E5%A0%86/" class="">Go 语言解「前 K 个高频元素」：从排序到堆的深度探索</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E7%AF%87%E9%9D%A2%E8%AF%95%E9%A2%98/" class="">面试题-go语言基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%85%A5%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/" class="active">深入螺旋矩阵</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/bfs%E5%92%8Cdfs/" class="">DFS vs BFS：算法世界的“深度”与“广度”，你该如何抉择？</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" class="">背包问题</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-c493bd57058cffd3653c22fc340e06bc" class="toggle"  />
    <label for="section-c493bd57058cffd3653c22fc340e06bc" class="flex">
      <a role="button" class="flex-auto ">AI面试</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/ai%E9%9D%A2%E8%AF%95/gemini0905/" class="">Gemini0905面试总结</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/ai%E9%9D%A2%E8%AF%95/mycache/" class="">MyCache项目面试问题</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>



  </div>
</aside>
 

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>深入螺旋矩阵</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#最初的尝试一个看似正确的解法">最初的尝试：一个看似正确的解法</a></li>
    <li><a href="#隐藏的陷阱当螺旋不再方正">隐藏的陷阱：当螺旋不再“方正”</a>
      <ul>
        <li><a href="#问题的根源">问题的根源</a></li>
      </ul>
    </li>
    <li><a href="#通用的解决方案可靠的边界检查">通用的解决方案：可靠的边界检查</a></li>
    <li><a href="#举一反三nn-矩阵真的没有问题吗">举一反三：n*n 矩阵真的没有问题吗？</a></li>
    <li><a href="#一个特例为什么生成矩阵的代码可以不用判断">一个特例：为什么“生成矩阵”的代码可以不用判断？</a></li>
    <li><a href="#最终的优化走向更优雅的代码">最终的优化：走向更优雅的代码</a>
      <ul>
        <li><a href="#最终的优化代码">最终的优化代码</a></li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      <div class="post-meta">
    <span class="post-date">
      <strong>Date:</strong> September 15, 2025
    </span><span class="post-tags">
      <strong>Tags:</strong><a href="https://xiaoli-lhx.github.io/tags/go/">Go</a><a href="https://xiaoli-lhx.github.io/tags/%E7%AE%97%E6%B3%95/">算法</a><a href="https://xiaoli-lhx.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a href="https://xiaoli-lhx.github.io/tags/leetcode/">LeetCode</a><a href="https://xiaoli-lhx.github.io/tags/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/">螺旋矩阵</a></span></div>
      
  <article class="markdown book-article"><h1 id="深入螺旋矩阵从一个小-bug到完美解法的思考之旅">
  深入螺旋矩阵：从一个“小 Bug”到“完美”解法的思考之旅
  
  <a class="anchor" href="#%e6%b7%b1%e5%85%a5%e8%9e%ba%e6%97%8b%e7%9f%a9%e9%98%b5%e4%bb%8e%e4%b8%80%e4%b8%aa%e5%b0%8f-bug%e5%88%b0%e5%ae%8c%e7%be%8e%e8%a7%a3%e6%b3%95%e7%9a%84%e6%80%9d%e8%80%83%e4%b9%8b%e6%97%85">#</a>
  
</h1>
<h2 id="前言">
  前言
  
  <a class="anchor" href="#%e5%89%8d%e8%a8%80">#</a>
  
</h2>
<p>“螺旋矩阵”是 LeetCode 上一道非常经典的算法题。它不仅考验我们对二维数组的操作能力，更考验我们对边界条件处理的细致程度。最近在刷这道题时，我写出了一个看似“正确”的解法，却在某些特定测试用例下意外翻车。</p>
<p>这篇文章记录了我从发现一个微小的 Bug，到层层深入分析其根源，再到举一反三，最终将代码优化到近乎完美的全过程。这趟思考之旅让我对“边界”二字有了更深刻的理解。</p>
<h2 id="最初的尝试一个看似正确的解法">
  最初的尝试：一个看似正确的解法
  
  <a class="anchor" href="#%e6%9c%80%e5%88%9d%e7%9a%84%e5%b0%9d%e8%af%95%e4%b8%80%e4%b8%aa%e7%9c%8b%e4%bc%bc%e6%ad%a3%e7%a1%ae%e7%9a%84%e8%a7%a3%e6%b3%95">#</a>
  
</h2>
<p>我的第一版代码思路非常直接：用 <code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code> 四个变量定义当前需要遍历的边界，模拟螺旋的四个步骤（左→右, 上→下, 右→左, 下→上），每走完一圈就收缩一圈边界。同时，用一个 <code>num</code> 计数器来确保我们不多不少，正好读取 <code>n*m</code> 个元素。</p>
<p>代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 最初的版本 - 看似正确，但有陷阱</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">spiralOrder</span>(<span style="color:#a6e22e">matrix</span> [][]<span style="color:#66d9ef">int</span>) []<span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">matrix</span>), len(<span style="color:#a6e22e">matrix</span>[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">total</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">m</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">top</span>, <span style="color:#a6e22e">bottom</span>, <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">n</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">m</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">num</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">res</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">num</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">total</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 1.左-&gt;右</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">left</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">right</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">res</span> = append(<span style="color:#a6e22e">res</span>, <span style="color:#a6e22e">matrix</span>[<span style="color:#a6e22e">top</span>][<span style="color:#a6e22e">i</span>])
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">num</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">top</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 2.上-&gt;下</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">top</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">bottom</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">res</span> = append(<span style="color:#a6e22e">res</span>, <span style="color:#a6e22e">matrix</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">right</span>])
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">num</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">right</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 3.右-&gt;左</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">right</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">left</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">--</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">res</span> = append(<span style="color:#a6e22e">res</span>, <span style="color:#a6e22e">matrix</span>[<span style="color:#a6e22e">bottom</span>][<span style="color:#a6e22e">i</span>])
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">num</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">bottom</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 4.下-&gt;上</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bottom</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">top</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">--</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">res</span> = append(<span style="color:#a6e22e">res</span>, <span style="color:#a6e22e">matrix</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">left</span>])
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">num</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">left</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这段代码在处理 <code>3x3</code> 这样的方形矩阵时，表现完美。然而，当我用一个 <code>3x4</code> 的矩阵进行测试时，问题暴露了。</p>
<h2 id="隐藏的陷阱当螺旋不再方正">
  隐藏的陷阱：当螺旋不再“方正”
  
  <a class="anchor" href="#%e9%9a%90%e8%97%8f%e7%9a%84%e9%99%b7%e9%98%b1%e5%bd%93%e8%9e%ba%e6%97%8b%e4%b8%8d%e5%86%8d%e6%96%b9%e6%ad%a3">#</a>
  
</h2>
<p>让我们用一个 <code>3x4</code> 的矩阵来手动走一遍流程：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span>[[1, 2, 3, 4],
</span></span><span style="display:flex;"><span> [5, 6, 7, 8],
</span></span><span style="display:flex;"><span> [9, 10, 11, 12]]
</span></span></code></pre></div><p>第一圈走完，结果 <code>res</code> 是 <code>[1, 2, 3, 4, 8, 12, 11, 10, 9, 5]</code>，一切正常。此时，<code>top=1</code>, <code>bottom=1</code>, <code>left=1</code>, <code>right=2</code>。</p>
<p>因为 <code>num</code> (11) 小于 <code>total</code> (12)，循环继续：</p>
<ol>
<li><strong>从左到右</strong>：读取 <code>6</code> 和 <code>7</code>。至此，所有12个元素都已读取。<code>num</code> 变成 <code>13</code>。</li>
<li><code>top++</code> 执行，<code>top</code> 变为 <code>2</code>。<strong>注意！此时 <code>top &gt; bottom</code>，边界已经交叉失效了！</strong></li>
<li>程序继续执行 <strong>“从右到左”</strong> 的循环。它的循环条件 <code>for i := right; i &gt;= left; i--</code> 仍然满足。它会错误地再次读取 <code>matrix[bottom][1]</code>，也就是 <code>matrix[1][1]</code>，把 <code>6</code> 又添加了一遍！</li>
</ol>
<h3 id="问题的根源">
  问题的根源
  
  <a class="anchor" href="#%e9%97%ae%e9%a2%98%e7%9a%84%e6%a0%b9%e6%ba%90">#</a>
  
</h3>
<p>在一个大的循环迭代内部，一个步骤（如 <code>top++</code>）导致的边界失效，并没有被后续的步骤（如“从右到左”）及时检查。<code>num &lt;= total</code> 这个总刹车“来不及”阻止这场“内部”的错误。</p>
<h2 id="通用的解决方案可靠的边界检查">
  通用的解决方案：可靠的边界检查
  
  <a class="anchor" href="#%e9%80%9a%e7%94%a8%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88%e5%8f%af%e9%9d%a0%e7%9a%84%e8%be%b9%e7%95%8c%e6%a3%80%e6%9f%a5">#</a>
  
</h2>
<p>既然找到了根源，解决方案就很明确了：在每一步可能出错的循环前，都加上一次即时的边界检查。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 3. 从右到左 (加上判断)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">top</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">bottom</span> { <span style="color:#75715e">// &lt;--- 在这里添加判断</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">right</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">left</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">--</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">bottom</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 4. 从下到上 (加上判断)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">left</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">right</span> { <span style="color:#75715e">// &lt;--- 在这里添加判断</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bottom</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">top</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">--</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">left</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>加上这两个 <code>if</code> 判断后，代码变得无懈可击，能够正确处理任何 <code>n*m</code> 的矩阵。</p>
<h2 id="举一反三nn-矩阵真的没有问题吗">
  举一反三：n*n 矩阵真的没有问题吗？
  
  <a class="anchor" href="#%e4%b8%be%e4%b8%80%e5%8f%8d%e4%b8%89nn-%e7%9f%a9%e9%98%b5%e7%9c%9f%e7%9a%84%e6%b2%a1%e6%9c%89%e9%97%ae%e9%a2%98%e5%90%97">#</a>
  
</h2>
<p>一个有趣的问题随之而来：是不是只有 <code>n*m</code> 的矩阵才有问题，<code>n*n</code> 的就没事？</p>
<p>答案是<strong>否定</strong>的。以 <code>3x3</code> 矩阵为例，当走完外圈，只剩下中心点 <code>5</code> 时。程序会在新一轮循环的“从左到右”步骤中读取 <code>5</code>，然后 <code>top++</code> 导致 <code>top &gt; bottom</code>。如果没有 <code>if top &lt;= bottom</code> 的保护，“从右到左”的步骤同样会再次读取 <code>5</code>，造成重复。</p>
<p>这证明了边界检查对于所有情况都是必需的。</p>
<h2 id="一个特例为什么生成矩阵的代码可以不用判断">
  一个特例：为什么“生成矩阵”的代码可以不用判断？
  
  <a class="anchor" href="#%e4%b8%80%e4%b8%aa%e7%89%b9%e4%be%8b%e4%b8%ba%e4%bb%80%e4%b9%88%e7%94%9f%e6%88%90%e7%9f%a9%e9%98%b5%e7%9a%84%e4%bb%a3%e7%a0%81%e5%8f%af%e4%bb%a5%e4%b8%8d%e7%94%a8%e5%88%a4%e6%96%ad">#</a>
  
</h2>
<p>在研究“生成螺旋矩阵”这道题时，我发现很多标准答案并没有加 <code>if</code> 判断，这又是为什么？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 生成 n*n 矩阵的代码</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">generateMatrix</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) [][]<span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">total</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">n</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">num</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">total</span> { <span style="color:#75715e">// 关键点在这里</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ... (没有 if 判断)</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>原因在于，<strong>“生成”</strong> 这个场景下，<code>num</code> 计数器和已填充的格子数是<strong>完美同步</strong>的。当最后一个格子（例如 <code>3x3</code> 的中心点 <code>9</code>）被填充后，<code>num</code> 会立刻变成 <code>total + 1</code>。这导致外层的 <code>for num &lt;= total</code> 条件在下一次检查时立即失败，整个循环干净地结束，根本没有机会去执行后面那些可能出错的步骤。</p>
<p>这是一种“凑巧”的完美刹车，但它依赖于 <code>n*n</code> 这个规则的场景。</p>
<h2 id="最终的优化走向更优雅的代码">
  最终的优化：走向更优雅的代码
  
  <a class="anchor" href="#%e6%9c%80%e7%bb%88%e7%9a%84%e4%bc%98%e5%8c%96%e8%b5%b0%e5%90%91%e6%9b%b4%e4%bc%98%e9%9b%85%e7%9a%84%e4%bb%a3%e7%a0%81">#</a>
  
</h2>
<p>解决了 Bug 之后，我们还可以从两个方面优化代码：</p>
<ol>
<li><strong>更优雅的循环条件</strong>：去掉 <code>num</code> 和 <code>total</code>，直接使用边界状态作为循环条件 <code>for top &lt;= bottom &amp;&amp; left &lt;= right</code>，这让代码的意图更清晰。</li>
<li><strong>更高的性能</strong>：我们从一开始就知道结果切片的总长度是 <code>n*m</code>。使用 <code>make([]int, n*m)</code> 预先分配好内存，并通过索引直接赋值，可以避免 <code>append</code> 带来的多次底层数组扩容开销。</li>
</ol>
<h3 id="最终的优化代码">
  最终的优化代码
  
  <a class="anchor" href="#%e6%9c%80%e7%bb%88%e7%9a%84%e4%bc%98%e5%8c%96%e4%bb%a3%e7%a0%81">#</a>
  
</h3>
<p>最终，我们得到了一份非常健壮、高效且优雅的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 最终优化版本</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">spiralOrder</span>(<span style="color:#a6e22e">matrix</span> [][]<span style="color:#66d9ef">int</span>) []<span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">matrix</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> []<span style="color:#66d9ef">int</span>{}
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">matrix</span>), len(<span style="color:#a6e22e">matrix</span>[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">res</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">n</span><span style="color:#f92672">*</span><span style="color:#a6e22e">m</span>) 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">index</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">top</span>, <span style="color:#a6e22e">bottom</span>, <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">n</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">m</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">top</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">bottom</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">left</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">right</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">left</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">right</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">res</span>[<span style="color:#a6e22e">index</span>] = <span style="color:#a6e22e">matrix</span>[<span style="color:#a6e22e">top</span>][<span style="color:#a6e22e">i</span>]
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">index</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">top</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">top</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">bottom</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">res</span>[<span style="color:#a6e22e">index</span>] = <span style="color:#a6e22e">matrix</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">right</span>]
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">index</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">right</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">top</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">bottom</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">right</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">left</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">--</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">res</span>[<span style="color:#a6e22e">index</span>] = <span style="color:#a6e22e">matrix</span>[<span style="color:#a6e22e">bottom</span>][<span style="color:#a6e22e">i</span>]
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">index</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">bottom</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">left</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">right</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bottom</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">top</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">--</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">res</span>[<span style="color:#a6e22e">index</span>] = <span style="color:#a6e22e">matrix</span>[<span style="color:#a6e22e">i</span>][<span style="color:#a6e22e">left</span>]
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">index</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">left</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="总结">
  总结
  
  <a class="anchor" href="#%e6%80%bb%e7%bb%93">#</a>
  
</h2>
<p>这次螺旋矩阵的调试之旅，让我深刻体会到：</p>
<ol>
<li><strong>边界条件是魔鬼</strong>：一个看似完美的算法，可能在某个不起眼的角落因为边界问题而崩溃。</li>
<li><strong>充分测试是关键</strong>：用不同形状（<code>n*n</code>, <code>n*m</code>, <code>1*n</code>, <code>n*1</code>）的矩阵去测试，是发现问题的最好方式。</li>
<li><strong>理解问题根源</strong>：只有理解了 Bug 发生的根本原因，才能写出真正健壮的解决方案，而不是仅仅“特事特办”。</li>
</ol>
<p>最终，最可靠的方案，往往也是最简单的那个——<strong>在每一步操作前，都清晰地检查其先决条件。</strong></p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  



  
  
  
  <div class="flex flex-wrap justify-between">
    <span>
    
      <a href="/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E7%AF%87%E9%9D%A2%E8%AF%95%E9%A2%98/" class="flex align-center book-icon">
        <img src="/svg/backward.svg" class="book-icon" alt="Previous" title="面试题-go语言基础" />
        <span>面试题-go语言基础</span>
      </a>
    
    </span>
    <span>
    
      <a href="/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/bfs%E5%92%8Cdfs/" class="flex align-center book-icon">
        <span>DFS vs BFS：算法世界的“深度”与“广度”，你该如何抉择？</span>
        <img src="/svg/forward.svg" class="book-icon" alt="Next" title="DFS vs BFS：算法世界的“深度”与“广度”，你该如何抉择？" />
      </a>
    
    </span>
  </div>
  




  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 
      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    

<aside class="book-toc">
  <div class="book-toc-content">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#最初的尝试一个看似正确的解法">最初的尝试：一个看似正确的解法</a></li>
    <li><a href="#隐藏的陷阱当螺旋不再方正">隐藏的陷阱：当螺旋不再“方正”</a>
      <ul>
        <li><a href="#问题的根源">问题的根源</a></li>
      </ul>
    </li>
    <li><a href="#通用的解决方案可靠的边界检查">通用的解决方案：可靠的边界检查</a></li>
    <li><a href="#举一反三nn-矩阵真的没有问题吗">举一反三：n*n 矩阵真的没有问题吗？</a></li>
    <li><a href="#一个特例为什么生成矩阵的代码可以不用判断">一个特例：为什么“生成矩阵”的代码可以不用判断？</a></li>
    <li><a href="#最终的优化走向更优雅的代码">最终的优化：走向更优雅的代码</a>
      <ul>
        <li><a href="#最终的优化代码">最终的优化代码</a></li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
  </ul>
</nav>



  </div>
</aside>

 
  </main>

  <footer style="text-align: center; padding: 20px 0; margin-top: 40px;">
    <p>Copyright © 2025 LHX. All Rights Reserved.</p>
</footer>
</body>
</html>
















