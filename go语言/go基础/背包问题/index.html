<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  背包问题终极攻略：一文学会所有变种（Go语言实现）
  
  #
  

在动态规划的宏伟殿堂中，背包问题无疑是看门人，也是最经典的试金石。它形态多变，时而求最大价值，时而求方案总数；时而物品只能用一次，时而又能无限取用。
许多初学者（甚至是有经验的开发者）在面对这些变种时，常常会混淆递推公式和循环顺序，导致“感觉会了，一写就错”。
别担心，这篇文章将彻底终结你的烦恼。我们将通过三个核心维度，为你建立一个清晰的思考框架，让你能够轻松识别并解决几乎所有的背包问题。所有代码都将以 Go 语言 和一维 DP 空间优化的形式呈现。

  三个核心维度，解锁所有背包问题
  
  #
  

忘掉那些死记硬背的模板吧！所有背包问题的变化，都可以归结为这三个维度的不同组合：

目标不同 (求价值 vs 求方法数)

求最大价值：核心是做选择，递推公式通常是 max()。
求方案总数：核心是累加所有可能性，递推公式通常是 &#43;=。


物品使用次数不同 (0/1 vs 完全背包)

0/1 背包 (每种物品最多用1次)：内层循环（遍历容量）必须倒序。
完全背包 (每种物品可用无限次)：内层循环（遍历容量）必须正序。


方案是否考虑顺序 (组合 vs 排列)

求组合 (顺序无关，{1,2} 和 {2,1} 算一种)：外层循环遍历物品，内层循环遍历容量。
求排列 (顺序相关，{1,2} 和 {2,1} 算两种)：外层循环遍历容量，内层循环遍历物品。



接下来，我们将用经典的例子来逐一解析这些维度组合出的题型。


  一、求最大价值
  
  #
  

这是背包问题最常见的形态，我们的目标是在有限的容量内，让装入的物品价值最大化。

  1. 经典0/1背包：求最大价值
  
  #
  



  问题特征：每个物品最多只能选择一次，求能获得的最大总价值。
核心维度：求最大价值 &#43; 0/1背包
实现要点：max() &#43; 倒序内循环
💡 为什么内循环要倒序？
为了保证每个物品只被选择一次。在更新 dp[j] 时，我们需要 dp[j-weight[i]] 是上一轮（即不包含物品 i）的状态。倒序遍历时，当我们计算 dp[j]，dp[j-weight[i]] 尚未被本轮更新，仍是旧值，符合0/1定义。">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/">
  <meta property="og:site_name" content="Blog">
  <meta property="og:title" content="背包问题">
  <meta property="og:description" content="背包问题终极攻略：一文学会所有变种（Go语言实现）#在动态规划的宏伟殿堂中，背包问题无疑是看门人，也是最经典的试金石。它形态多变，时而求最大价值，时而求方案总数；时而物品只能用一次，时而又能无限取用。
许多初学者（甚至是有经验的开发者）在面对这些变种时，常常会混淆递推公式和循环顺序，导致“感觉会了，一写就错”。
别担心，这篇文章将彻底终结你的烦恼。我们将通过三个核心维度，为你建立一个清晰的思考框架，让你能够轻松识别并解决几乎所有的背包问题。所有代码都将以 Go 语言 和一维 DP 空间优化的形式呈现。
三个核心维度，解锁所有背包问题#忘掉那些死记硬背的模板吧！所有背包问题的变化，都可以归结为这三个维度的不同组合：
目标不同 (求价值 vs 求方法数) 求最大价值：核心是做选择，递推公式通常是 max()。 求方案总数：核心是累加所有可能性，递推公式通常是 &#43;=。 物品使用次数不同 (0/1 vs 完全背包) 0/1 背包 (每种物品最多用1次)：内层循环（遍历容量）必须倒序。 完全背包 (每种物品可用无限次)：内层循环（遍历容量）必须正序。 方案是否考虑顺序 (组合 vs 排列) 求组合 (顺序无关，{1,2} 和 {2,1} 算一种)：外层循环遍历物品，内层循环遍历容量。 求排列 (顺序相关，{1,2} 和 {2,1} 算两种)：外层循环遍历容量，内层循环遍历物品。 接下来，我们将用经典的例子来逐一解析这些维度组合出的题型。
一、求最大价值#这是背包问题最常见的形态，我们的目标是在有限的容量内，让装入的物品价值最大化。
1. 经典0/1背包：求最大价值#问题特征：每个物品最多只能选择一次，求能获得的最大总价值。
核心维度：求最大价值 &#43; 0/1背包
实现要点：max() &#43; 倒序内循环
💡 为什么内循环要倒序？
为了保证每个物品只被选择一次。在更新 dp[j] 时，我们需要 dp[j-weight[i]] 是上一轮（即不包含物品 i）的状态。倒序遍历时，当我们计算 dp[j]，dp[j-weight[i]] 尚未被本轮更新，仍是旧值，符合0/1定义。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="go语言">
    <meta property="article:published_time" content="2025-10-14T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-10-14T00:00:00+00:00">
    <meta property="article:tag" content="Go">
    <meta property="article:tag" content="算法">
    <meta property="article:tag" content="动态规划">
    <meta property="article:tag" content="LeetCode">
    <meta property="article:tag" content="背包问题">
<title>背包问题 | Blog</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/">
<link rel="stylesheet" href="/book.min.ce742184041b67827be505801d71b6b40c09608dfb292033ea54dbbc1d71a174.css" integrity="sha256-znQhhAQbZ4J75QWAHXG2tAwJYI37KSAz6lTbvB1xoXQ=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.4252892e0f19cc49afbe25b7f2eb0ae35725e8125f94af588825010da864f339.js" integrity="sha256-QlKJLg8ZzEmvviW38usK41cl6BJflK9YiCUBDahk8zk=" crossorigin="anonymous"></script>

  <script defer src="/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js" integrity="sha256-b2&#43;Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC&#43;NdcPIvZhzk=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  <link rel="stylesheet" href="/css/custom.css">
</head>
<body dir="ltr" class="book-kind-page book-type-go语言">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    
<aside class="book-menu">
  <div class="book-menu-content">
    
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>Blog</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>













  



  
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-ece2958ce52732215c05ee4fd8e37c4b" class="toggle"  />
    <label for="section-ece2958ce52732215c05ee4fd8e37c4b" class="flex">
      <a role="button" class="flex-auto ">计网</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2998acf51f5f0061bff7de261b935769" class="toggle"  />
    <label for="section-2998acf51f5f0061bff7de261b935769" class="flex">
      <a role="button" class="flex-auto ">基础篇</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/%E8%AE%A1%E7%BD%91/%E5%9F%BA%E7%A1%80%E7%AF%87/tcp_ip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E5%B1%82/" class="">TCP/IP网络模型有哪几层？</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/%E8%AE%A1%E7%BD%91/%E5%9F%BA%E7%A1%80%E7%AF%87/url_about/" class="">在浏览器中输入URL并按下回车之和会发生什么</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-663286454c4cd9ce11659bd2eb980fee" class="toggle"  />
    <label for="section-663286454c4cd9ce11659bd2eb980fee" class="flex">
      <a role="button" class="flex-auto ">TCP篇</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/%E8%AE%A1%E7%BD%91/tcp%E7%AF%87/tcp%E7%AF%87/" class="">TCP篇</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-67b43edca1c269c7246a75d4308d3b1b" class="toggle" checked />
    <label for="section-67b43edca1c269c7246a75d4308d3b1b" class="flex">
      <a role="button" class="flex-auto ">Go语言</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-770547d614dac05a040d1a3ecfcd842c" class="toggle" checked />
    <label for="section-770547d614dac05a040d1a3ecfcd842c" class="flex">
      <a role="button" class="flex-auto ">Go基础</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E5%9F%BA%E7%A1%80/" class="">Go语言基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%8B%9F%E6%A0%88/" class="">Go语言中栈的实现：Slice还是List？</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E8%AF%AD%E8%A8%80%E5%A0%86/" class="">Go 语言解「前 K 个高频元素」：从排序到堆的深度探索</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E7%AF%87%E9%9D%A2%E8%AF%95%E9%A2%98/" class="">面试题-go语言基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/%E6%B7%B1%E5%85%A5%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/" class="">深入螺旋矩阵</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/bfs%E5%92%8Cdfs/" class="">DFS vs BFS：算法世界的“深度”与“广度”，你该如何抉择？</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" class="active">背包问题</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-c493bd57058cffd3653c22fc340e06bc" class="toggle"  />
    <label for="section-c493bd57058cffd3653c22fc340e06bc" class="flex">
      <a role="button" class="flex-auto ">AI面试</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/ai%E9%9D%A2%E8%AF%95/gemini0905/" class="">Gemini0905面试总结</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/ai%E9%9D%A2%E8%AF%95/mycache/" class="">MyCache项目面试问题</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>



  </div>
</aside>
 

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>背包问题</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#背包问题终极攻略一文学会所有变种go语言实现">背包问题终极攻略：一文学会所有变种（Go语言实现）</a>
      <ul>
        <li><a href="#三个核心维度解锁所有背包问题">三个核心维度，解锁所有背包问题</a></li>
        <li><a href="#一求最大价值">一、求最大价值</a></li>
        <li><a href="#二求方案总数">二、求方案总数</a></li>
        <li><a href="#终极总结你的背包问题速查表">终极总结：你的背包问题速查表</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      <div class="post-meta">
    <span class="post-date">
      <strong>Date:</strong> October 14, 2025
    </span><span class="post-tags">
      <strong>Tags:</strong><a href="https://xiaoli-lhx.github.io/tags/go/">Go</a><a href="https://xiaoli-lhx.github.io/tags/%E7%AE%97%E6%B3%95/">算法</a><a href="https://xiaoli-lhx.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a><a href="https://xiaoli-lhx.github.io/tags/leetcode/">LeetCode</a><a href="https://xiaoli-lhx.github.io/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/">背包问题</a></span></div>
      
  <article class="markdown book-article"><h2 id="背包问题终极攻略一文学会所有变种go语言实现">
  背包问题终极攻略：一文学会所有变种（Go语言实现）
  
  <a class="anchor" href="#%e8%83%8c%e5%8c%85%e9%97%ae%e9%a2%98%e7%bb%88%e6%9e%81%e6%94%bb%e7%95%a5%e4%b8%80%e6%96%87%e5%ad%a6%e4%bc%9a%e6%89%80%e6%9c%89%e5%8f%98%e7%a7%8dgo%e8%af%ad%e8%a8%80%e5%ae%9e%e7%8e%b0">#</a>
  
</h2>
<p>在动态规划的宏伟殿堂中，背包问题无疑是看门人，也是最经典的试金石。它形态多变，时而求最大价值，时而求方案总数；时而物品只能用一次，时而又能无限取用。</p>
<p>许多初学者（甚至是有经验的开发者）在面对这些变种时，常常会混淆递推公式和循环顺序，导致“感觉会了，一写就错”。</p>
<p>别担心，这篇文章将彻底终结你的烦恼。我们将通过<strong>三个核心维度</strong>，为你建立一个清晰的思考框架，让你能够轻松识别并解决几乎所有的背包问题。所有代码都将以 <strong>Go 语言</strong> 和<strong>一维 DP 空间优化</strong>的形式呈现。</p>
<h3 id="三个核心维度解锁所有背包问题">
  三个核心维度，解锁所有背包问题
  
  <a class="anchor" href="#%e4%b8%89%e4%b8%aa%e6%a0%b8%e5%bf%83%e7%bb%b4%e5%ba%a6%e8%a7%a3%e9%94%81%e6%89%80%e6%9c%89%e8%83%8c%e5%8c%85%e9%97%ae%e9%a2%98">#</a>
  
</h3>
<p>忘掉那些死记硬背的模板吧！所有背包问题的变化，都可以归结为这三个维度的不同组合：</p>
<ol>
<li><strong>目标不同 (求价值 vs 求方法数)</strong>
<ul>
<li><strong>求最大价值</strong>：核心是做选择，递推公式通常是 <code>max()</code>。</li>
<li><strong>求方案总数</strong>：核心是累加所有可能性，递推公式通常是 <code>+=</code>。</li>
</ul>
</li>
<li><strong>物品使用次数不同 (0/1 vs 完全背包)</strong>
<ul>
<li><strong>0/1 背包</strong> (每种物品最多用1次)：内层循环（遍历容量）必须<strong>倒序</strong>。</li>
<li><strong>完全背包</strong> (每种物品可用无限次)：内层循环（遍历容量）必须<strong>正序</strong>。</li>
</ul>
</li>
<li><strong>方案是否考虑顺序 (组合 vs 排列)</strong>
<ul>
<li><strong>求组合</strong> (顺序无关，<code>{1,2}</code> 和 <code>{2,1}</code> 算一种)：外层循环遍历<strong>物品</strong>，内层循环遍历<strong>容量</strong>。</li>
<li><strong>求排列</strong> (顺序相关，<code>{1,2}</code> 和 <code>{2,1}</code> 算两种)：外层循环遍历<strong>容量</strong>，内层循环遍历<strong>物品</strong>。</li>
</ul>
</li>
</ol>
<p>接下来，我们将用经典的例子来逐一解析这些维度组合出的题型。</p>
<hr>
<h3 id="一求最大价值">
  一、求最大价值
  
  <a class="anchor" href="#%e4%b8%80%e6%b1%82%e6%9c%80%e5%a4%a7%e4%bb%b7%e5%80%bc">#</a>
  
</h3>
<p>这是背包问题最常见的形态，我们的目标是在有限的容量内，让装入的物品价值最大化。</p>
<h4 id="1-经典01背包求最大价值">
  1. 经典0/1背包：求最大价值
  
  <a class="anchor" href="#1-%e7%bb%8f%e5%85%b801%e8%83%8c%e5%8c%85%e6%b1%82%e6%9c%80%e5%a4%a7%e4%bb%b7%e5%80%bc">#</a>
  
</h4>

<blockquote class='book-hint '>
  <p>问题特征：每个物品最多只能选择一次，求能获得的最大总价值。</p>
<p>核心维度：求最大价值 + 0/1背包</p>
<p>实现要点：max() + 倒序内循环</p>
</blockquote><p>💡 为什么内循环要倒序？</p>
<p>为了保证每个物品只被选择一次。在更新 dp[j] 时，我们需要 dp[j-weight[i]] 是上一轮（即不包含物品 i）的状态。倒序遍历时，当我们计算 dp[j]，dp[j-weight[i]] 尚未被本轮更新，仍是旧值，符合0/1定义。</p>
<p><strong>示例：
  <a href="https://leetcode.cn/problems/partition-equal-subset-sum/">LeetCode 416. 分割等和子集</a></strong></p>
<ul>
<li><strong>问题转换</strong>：能否将数组分成两个和相等的子集？这等价于：能否从数组中找到一个子集，其和恰好为 <code>sum / 2</code>？</li>
<li><strong>背包类比</strong>：
<ul>
<li>背包容量 = <code>sum / 2</code></li>
<li>物品重量 = <code>nums[i]</code></li>
<li>物品价值 = <code>nums[i]</code></li>
</ul>
</li>
<li><strong>目标</strong>：求背包能装下的最大价值。如果这个最大价值恰好等于背包容量，说明问题有解。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 0/1背包：求最大价值</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">canPartition</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">num</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">nums</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">num</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sum</span><span style="color:#f92672">%</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">target</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sum</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// dp[j] 表示容量为j的背包，能装下的最大价值</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dp</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">target</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 外层遍历物品</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">num</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">nums</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内层倒序遍历容量</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">target</span>; <span style="color:#a6e22e">j</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">num</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">--</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">j</span>] = max(<span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">j</span>], <span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">j</span><span style="color:#f92672">-</span><span style="color:#a6e22e">num</span>]<span style="color:#f92672">+</span><span style="color:#a6e22e">num</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">target</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">target</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> max(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span> &gt; <span style="color:#a6e22e">b</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">b</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="2-完全背包求最大价值">
  2. 完全背包：求最大价值
  
  <a class="anchor" href="#2-%e5%ae%8c%e5%85%a8%e8%83%8c%e5%8c%85%e6%b1%82%e6%9c%80%e5%a4%a7%e4%bb%b7%e5%80%bc">#</a>
  
</h4>

<blockquote class='book-hint '>
  <p>问题特征：每个物品可以无限次选择，求能获得的最大总价值。</p>
<p>核心维度：求最大价值 + 完全背包</p>
<p>实现要点：max() + 正序内循环</p>
</blockquote><p>💡 为什么内循环要正序？</p>
<p>正序遍历时，当我们计算 dp[j]，dp[j-weight[i]] 可能已经是本轮更新过的值了。这意味着 dp[j-weight[i]] 的最优解中可能已经包含了物品 i。在此基础上再给它加上一个物品 i 的价值，就巧妙地实现了“物品 i 可以被选择多次”。</p>
<p><strong>示例：
  <a href="https://kamacoder.com/problempage.php?pid=1052">卡码网52.“小明的研究材料”</a></strong></p>
<ul>
<li><strong>问题转换</strong>：这是一个裸的完全背包问题。</li>
<li><strong>背包类比</strong>：
<ul>
<li>背包容量 = <code>bagWeight</code></li>
<li>物品重量 = <code>weight[i]</code></li>
<li>物品价值 = <code>value[i]</code></li>
</ul>
</li>
<li><strong>目标</strong>：求背包能装下的最大价值。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 完全背包：求最大价值</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">completeKnapsackValue</span>(<span style="color:#a6e22e">weight</span>, <span style="color:#a6e22e">value</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">bagWeight</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">weight</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// dp[j] 表示容量为j的背包，能装下的最大价值</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dp</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">bagWeight</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 外层遍历物品</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内层正序遍历容量</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">weight</span>[<span style="color:#a6e22e">i</span>]; <span style="color:#a6e22e">j</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">bagWeight</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">j</span>] = max(<span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">j</span>], <span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">j</span><span style="color:#f92672">-</span><span style="color:#a6e22e">weight</span>[<span style="color:#a6e22e">i</span>]]<span style="color:#f92672">+</span><span style="color:#a6e22e">value</span>[<span style="color:#a6e22e">i</span>])
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">bagWeight</span>]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="二求方案总数">
  二、求方案总数
  
  <a class="anchor" href="#%e4%ba%8c%e6%b1%82%e6%96%b9%e6%a1%88%e6%80%bb%e6%95%b0">#</a>
  
</h3>
<p>这类问题不关心价值，只关心有多少种方法可以恰好装满背包。</p>
<h4 id="1-完全背包求组合数">
  1. 完全背包：求组合数
  
  <a class="anchor" href="#1-%e5%ae%8c%e5%85%a8%e8%83%8c%e5%8c%85%e6%b1%82%e7%bb%84%e5%90%88%e6%95%b0">#</a>
  
</h4>

<blockquote class='book-hint '>
  <p>问题特征：每个物品可以无限次选择，问恰好装满背包的组合有多少种。</p>
<p>核心维度：求方案数 + 完全背包 + 组合</p>
<p>实现要点：+= + 正序内循环 + 物品在外，容量在内</p>
</blockquote><p>💡 为什么“物品在外，容量在内”是组合？</p>
<p>因为我们是按顺序固定一个物品，然后用这个物品去更新所有容量的方案数。例如，先用1元硬币更新所有金额，再用2元硬币更新。这样 1+2 的组合只会在考虑2元硬币时，在 dp[1] 的基础上产生；而 2+1 这种顺序永远不会出现，从而保证了结果是组合。</p>
<p><strong>示例：
  <a href="https://leetcode.cn/problems/coin-change-ii/">LeetCode 518. 零钱兑换 II</a></strong></p>
<ul>
<li><strong>问题转换</strong>：用给定的硬币凑成总金额，有多少种组合方式？</li>
<li><strong>背包类比</strong>：
<ul>
<li>背包容量 = <code>amount</code></li>
<li>物品重量 = <code>coins[i]</code></li>
</ul>
</li>
<li><strong>目标</strong>：求装满背包的方案组合数。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 完全背包：求组合数</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">change</span>(<span style="color:#a6e22e">amount</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">coins</span> []<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// dp[j] 表示金额为j的组合数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dp</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">amount</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dp</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">1</span> <span style="color:#75715e">// 凑成金额0的组合数为1（什么都不选）</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 外层遍历物品（硬币）</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">coin</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">coins</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内层正序遍历容量（金额）</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">coin</span>; <span style="color:#a6e22e">j</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">amount</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">j</span>] <span style="color:#f92672">+=</span> <span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">j</span><span style="color:#f92672">-</span><span style="color:#a6e22e">coin</span>]
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">amount</span>]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="2-完全背包求排列数">
  2. 完全背包：求排列数
  
  <a class="anchor" href="#2-%e5%ae%8c%e5%85%a8%e8%83%8c%e5%8c%85%e6%b1%82%e6%8e%92%e5%88%97%e6%95%b0">#</a>
  
</h4>

<blockquote class='book-hint '>
  <p>问题特征：每个物品可以无限次选择，问恰好装满背包的排列有多少种。</p>
<p>核心维度：求方案数 + 完全背包 + 排列</p>
<p>实现要点：+= + 正序内循环 + 容量在外，物品在内</p>
</blockquote><p>💡 为什么“容量在外，物品在内”是排列？</p>
<p>因为我们是按顺序固定一个容量 j，然后尝试用所有物品作为最后一步来达到它。例如，计算 dp[3] 时，我们会尝试 dp[2]+1，也会尝试 dp[1]+2。1+2 和 2+1 这两种不同的排列都被独立计算并累加，从而保证了结果是排列。</p>
<p><strong>示例：
  <a href="https://leetcode.cn/problems/combination-sum-iv/">LeetCode 377. 组合总和 IV</a></strong></p>
<ul>
<li><strong>问题转换</strong>：用给定数字凑成目标和，有多少种排列方式？</li>
<li><strong>背包类比</strong>：
<ul>
<li>背包容量 = <code>target</code></li>
<li>物品重量 = <code>nums[i]</code></li>
</ul>
</li>
<li><strong>目标</strong>：求装满背包的方案排列数。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 完全背包：求排列数</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">combinationSum4</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">target</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// dp[j] 表示目标和为j的排列总数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dp</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">target</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dp</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 外层遍历容量（目标和）</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">j</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">target</span>; <span style="color:#a6e22e">j</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内层遍历物品</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">num</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">nums</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">j</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">num</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">j</span>] <span style="color:#f92672">+=</span> <span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">j</span><span style="color:#f92672">-</span><span style="color:#a6e22e">num</span>]
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">dp</span>[<span style="color:#a6e22e">target</span>]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="终极总结你的背包问题速查表">
  终极总结：你的背包问题速查表
  
  <a class="anchor" href="#%e7%bb%88%e6%9e%81%e6%80%bb%e7%bb%93%e4%bd%a0%e7%9a%84%e8%83%8c%e5%8c%85%e9%97%ae%e9%a2%98%e9%80%9f%e6%9f%a5%e8%a1%a8">#</a>
  
</h3>
<p>现在，让我们把所有知识点浓缩成一张终极速查表。下次遇到背包问题，对照此表，你将无往不利！</p>
<table>
  <thead>
      <tr>
          <th>问题类型</th>
          <th>核心思想</th>
          <th>外层循环</th>
          <th>内层循环</th>
          <th>递推公式</th>
          <th>初始化</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>0/1背包 (求最大价值)</strong></td>
          <td>每件用1次，求最大价值</td>
          <td><code>for</code> 物品</td>
          <td><code>for</code> 容量 (<strong>倒序</strong>)</td>
          <td><code>dp[j] = max(dp[j], ...)</code></td>
          <td><code>dp</code> 全为 <code>0</code></td>
      </tr>
      <tr>
          <td><strong>完全背包 (求最大价值)</strong></td>
          <td>每件无限用，求最大价值</td>
          <td><code>for</code> 物品</td>
          <td><code>for</code> 容量 (<strong>正序</strong>)</td>
          <td><code>dp[j] = max(dp[j], ...)</code></td>
          <td><code>dp</code> 全为 <code>0</code></td>
      </tr>
      <tr>
          <td><strong>完全背包 (求组合数)</strong></td>
          <td>每件无限用，求方案组合</td>
          <td><code>for</code> 物品</td>
          <td><code>for</code> 容量 (<strong>正序</strong>)</td>
          <td><code>dp[j] += dp[j-...]</code></td>
          <td><code>dp[0] = 1</code></td>
      </tr>
      <tr>
          <td><strong>完全背包 (求排列数)</strong></td>
          <td>每件无限用，求方案排列</td>
          <td><code>for</code> 容量</td>
          <td><code>for</code> 物品</td>
          <td><code>dp[j] += dp[j-...]</code></td>
          <td><code>dp[0] = 1</code></td>
      </tr>
      <tr>
          <td><strong>0/1背包 (求组合数)</strong></td>
          <td>每件用1次，求方案组合</td>
          <td><code>for</code> 物品</td>
          <td><code>for</code> 容量 (<strong>倒序</strong>)</td>
          <td><code>dp[j] += dp[j-...]</code></td>
          <td><code>dp[0] = 1</code></td>
      </tr>
  </tbody>
</table>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  



  
  
  
  <div class="flex flex-wrap justify-between">
    <span>
    
      <a href="/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/bfs%E5%92%8Cdfs/" class="flex align-center book-icon">
        <img src="/svg/backward.svg" class="book-icon" alt="Previous" title="DFS vs BFS：算法世界的“深度”与“广度”，你该如何抉择？" />
        <span>DFS vs BFS：算法世界的“深度”与“广度”，你该如何抉择？</span>
      </a>
    
    </span>
    <span>
    
      <a href="/ai%E9%9D%A2%E8%AF%95/gemini0905/" class="flex align-center book-icon">
        <span>Gemini0905面试总结</span>
        <img src="/svg/forward.svg" class="book-icon" alt="Next" title="Gemini0905面试总结" />
      </a>
    
    </span>
  </div>
  




  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 
      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    

<aside class="book-toc">
  <div class="book-toc-content">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#背包问题终极攻略一文学会所有变种go语言实现">背包问题终极攻略：一文学会所有变种（Go语言实现）</a>
      <ul>
        <li><a href="#三个核心维度解锁所有背包问题">三个核心维度，解锁所有背包问题</a></li>
        <li><a href="#一求最大价值">一、求最大价值</a></li>
        <li><a href="#二求方案总数">二、求方案总数</a></li>
        <li><a href="#终极总结你的背包问题速查表">终极总结：你的背包问题速查表</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </div>
</aside>

 
  </main>

  <footer style="text-align: center; padding: 20px 0; margin-top: 40px;">
    <p>Copyright © 2025 LHX. All Rights Reserved.</p>
</footer>
</body>
</html>
















