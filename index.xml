<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog</title>
    <link>https://xiaoli-lhx.github.io/</link>
    <description>Recent content on Blog</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 27 Aug 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://xiaoli-lhx.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go语言基础</title>
      <link>https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 26 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E5%9F%BA%E7%A1%80/</guid>
      <description>&lt;h1 id=&#34;go语言基础&#34;&gt;&#xD;&#xA;  Go语言基础&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#go%e8%af%ad%e8%a8%80%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;8.26 已完成：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; go的特点与优势&lt;/li&gt;&#xA;&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 包管理&lt;/li&gt;&#xA;&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 实现重载&lt;/li&gt;&#xA;&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 实现继承&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;TODO：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 实现多态&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 切片与数组区别&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; slice相关&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; struct与class&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 错误处理机制&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;1-和java对比介绍一下go语言的优势和特点&#34;&gt;&#xD;&#xA;  1. 和Java对比，介绍一下go语言的优势和特点&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%e5%92%8cjava%e5%af%b9%e6%af%94%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8bgo%e8%af%ad%e8%a8%80%e7%9a%84%e4%bc%98%e5%8a%bf%e5%92%8c%e7%89%b9%e7%82%b9&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;&lt;strong&gt;考点&lt;/strong&gt;：对编程语言的理解&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;难度&lt;/strong&gt;：简单&lt;/p&gt;&#xA;&lt;p&gt;总的来说，Go语言在性能、并发处理、部署和开发效率上都有其独特的优势，尤其适合网络服务和云计算领域&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;语法简洁：Go语言的语法非常简洁，没有类和继承等概念，代码易于维护和读写&lt;/li&gt;&#xA;&lt;li&gt;编译型语言：Go语言是一种编译型语言，编译成机器码直接运行，且编译速度很快&lt;/li&gt;&#xA;&lt;li&gt;高性能：Go语言的执行速度接近于C/C++，速度比Java快&lt;/li&gt;&#xA;&lt;li&gt;并发支持：Go语言的并发模型是基于&lt;code&gt;goroutine&lt;/code&gt;和&lt;code&gt;channel&lt;/code&gt;，使得并发编程变的简单高效，而Java的多线程模型相对较为复杂一些&lt;/li&gt;&#xA;&lt;li&gt;内存管理：Go语言拥有自己的垃圾回收机制，简化了内存管理&lt;/li&gt;&#xA;&lt;li&gt;部署简单：Go程序编译后生成单一的可执行文件，部署非常简单&lt;/li&gt;&#xA;&lt;li&gt;标准库丰富：Go拥有高质量的标准库，涵盖网络、加密、数据结构等方面&lt;/li&gt;&#xA;&lt;li&gt;工具链：Go有一套强大的工具链，如用于格式化代码的&lt;code&gt;gofmt&lt;/code&gt;、用于性能分析的&lt;code&gt;pprof&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;静态类型：Go是静态类型语言，有助于在编译时捕捉错误&lt;/li&gt;&#xA;&lt;li&gt;跨平台编译：Go支持跨平台编译，可以很方便地为不同操作系统构建应用程序&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;2-go包管理的方式有哪些&#34;&gt;&#xD;&#xA;  2. go包管理的方式有哪些？&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2-go%e5%8c%85%e7%ae%a1%e7%90%86%e7%9a%84%e6%96%b9%e5%bc%8f%e6%9c%89%e5%93%aa%e4%ba%9b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;&lt;strong&gt;考点&lt;/strong&gt;：包管理&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;难度&lt;/strong&gt;：简单&lt;/p&gt;&#xA;&lt;p&gt;Go语言的包管理最开始是&lt;code&gt;GOPATH&lt;/code&gt;的方式，每个项目都需要放在&lt;code&gt;GOPATH&lt;/code&gt;的下面，Go会从&lt;code&gt;GOPATH&lt;/code&gt;的&lt;code&gt;src&lt;/code&gt;目录寻找所有的包。&lt;/p&gt;&#xA;&lt;p&gt;现在主要用&lt;code&gt;Go Modules&lt;/code&gt;，官方从1.11版本开始引入，成了官方推荐的包管理方式。不再依赖&lt;code&gt;GOPATH&lt;/code&gt;,可以直接在任何地方创建项目，通过&lt;code&gt;go.mod&lt;/code&gt;文件来管理依赖。&lt;/p&gt;&#xA;&lt;h2 id=&#34;3-go支持重载吗如何在go中实现一个方法的重载&#34;&gt;&#xD;&#xA;  3. Go支持重载吗？如何在Go中实现一个方法的&amp;quot;重载&amp;quot;？&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#3-go%e6%94%af%e6%8c%81%e9%87%8d%e8%bd%bd%e5%90%97%e5%a6%82%e4%bd%95%e5%9c%a8go%e4%b8%ad%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e6%96%b9%e6%b3%95%e7%9a%84%e9%87%8d%e8%bd%bd&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;&lt;strong&gt;考点&lt;/strong&gt;：方法重载&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;难度&lt;/strong&gt;：中等&lt;/p&gt;&#xA;&lt;p&gt;Go 不支持函数/方法的重载，你&lt;strong&gt;不能在同一个作用域中定义多个函数名相同但参数不同的函数&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;会报编译错误：&lt;strong&gt;“（function name） redeclared in this block”&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;可以通过以下方式&lt;strong&gt;模拟&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用接口+类型断言&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Add&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt;{}) &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt;{} {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;switch&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;aVal&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;.(&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bVal&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;);&lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;aVal&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;bVal&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;float64&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bVal&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.(&lt;span style=&#34;color:#66d9ef&#34;&gt;float64&lt;/span&gt;);&lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;aVal&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;bVal&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;使用组合+接口&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;不同的方法封装在不同的嵌套结构中，外部选择性调用这些方法&lt;/p&gt;</description>
    </item>
    <item>
      <title>TCP/IP网络模型有哪几层？</title>
      <link>https://xiaoli-lhx.github.io/%E8%AE%A1%E7%BD%91/%E5%9F%BA%E7%A1%80%E7%AF%87/tcp_ip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E5%B1%82/</link>
      <pubDate>Sun, 24 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://xiaoli-lhx.github.io/%E8%AE%A1%E7%BD%91/%E5%9F%BA%E7%A1%80%E7%AF%87/tcp_ip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E5%B1%82/</guid>
      <description>&lt;h1 id=&#34;tcpip网络模型有哪几层&#34;&gt;&#xD;&#xA;  TCP/IP网络模型有哪几层？&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#tcpip%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b%e6%9c%89%e5%93%aa%e5%87%a0%e5%b1%82&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;1-应用层&#34;&gt;&#xD;&#xA;  1. 应用层&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%e5%ba%94%e7%94%a8%e5%b1%82&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;最上层的，也是我们能直接接触到的就是&lt;strong&gt;应用层&lt;/strong&gt;（&lt;em&gt;Application Layer&lt;/em&gt;）,应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。应用层是不用去关心数据是如何传输的,应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-传输层&#34;&gt;&#xD;&#xA;  2. 传输层&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2-%e4%bc%a0%e8%be%93%e5%b1%82&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;应用层的数据包会传给传输层，&lt;strong&gt;传输层&lt;/strong&gt;（&lt;em&gt;Transport Layer&lt;/em&gt;）是为应用层提供网络支持的。&lt;/p&gt;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;script src=&#34;https://xiaoli-lhx.github.io/mermaid.min.js&#34;&gt;&lt;/script&gt;&#xD;&#xA;&#xD;&#xA;  &lt;script&gt;mermaid.initialize({&#xD;&#xA;  &#34;flowchart&#34;: {&#xD;&#xA;    &#34;useMaxWidth&#34;:true&#xD;&#xA;  },&#xD;&#xA;  &#34;theme&#34;: &#34;default&#34;&#xD;&#xA;}&#xD;&#xA;)&lt;/script&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;pre class=&#34;mermaid&#34;&gt;flowchart BT&#xD;&#xA;    传输层--&amp;gt;应用层A&#xD;&#xA;&#x9;传输层--&amp;gt;应用层B&lt;/pre&gt;&#xD;&#xA;&lt;p&gt;在传输层会有两个传输协议，分别是 &lt;code&gt;TCP&lt;/code&gt;和&lt;code&gt; UDP&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;TCP 的全称叫传输控制协议,TCP比&lt;code&gt;UDP&lt;/code&gt;多了很多特性，比如流量控制，超时重传，拥塞控制等,这些都是为了保证数据包能可靠的传输给对方。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;UDP&lt;/code&gt;相对来说很简单，简单到只负责发送数据包，不保证数据包能抵达对方，但他的实时性相对更好，传输效率也高&lt;/p&gt;&#xA;&lt;p&gt;当传输层的数据包大小超过&lt;code&gt;MSS&lt;/code&gt;(TCP 最大报文段长度)，就需要将数据包分块，这样即使中途有一个分块丢失或者损坏，只需要重新发送这一个分块，而不需要发送整个数据包。在TCP协议中，我们把每个分块成为一个TCP段&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;端口&lt;/strong&gt;：当设备作为接收方时，传输层则要负责把数据包传给应用，但一台设备可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用去分开来，这个编号就是端口。&lt;/p&gt;&#xA;&lt;p&gt;由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。&lt;/p&gt;&#xA;&lt;h2 id=&#34;3-网络层&#34;&gt;&#xD;&#xA;  3. 网络层&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#3-%e7%bd%91%e7%bb%9c%e5%b1%82&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;pre class=&#34;mermaid&#34;&gt;flowchart BT&#xD;&#xA;    网络层--&amp;gt;传输层A--&amp;gt;应用层A&#xD;&#xA;&#x9;网络层--&amp;gt;传输层B--&amp;gt;应用层B&lt;/pre&gt;&#xD;&#xA;&lt;p&gt;网络层最常使用的时IP协议，IP协议会将传输层的报文作为数据部分，再加上IP报头组成IP报文，如果IP报文大小超过MTU（以太网中一般为1500字节）就会再次进行分片，得到一个即将发送到网络的IP报文。&lt;/p&gt;&#xA;&lt;p&gt;网络层负责将数据从一个设备传输到另一个设备。&lt;/p&gt;&#xA;&lt;p&gt;需要将 IP 地址分成两种意义：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个是&lt;strong&gt;网络号&lt;/strong&gt;，负责标识该 IP 地址是属于哪个「子网」的；&lt;/li&gt;&#xA;&lt;li&gt;一个是&lt;strong&gt;主机号&lt;/strong&gt;，负责标识同一「子网」下的不同主机；&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这需要配合&lt;strong&gt;子网掩码&lt;/strong&gt;才能算出 IP 地址 的网络号和主机号。&lt;/p&gt;&#xA;&lt;p&gt;将IP地址与子网掩码&lt;strong&gt;按位与运算&lt;/strong&gt;，就可以得到网络号。&lt;/p&gt;&#xA;&lt;p&gt;将子网掩码取反后与IP地址进行进行&lt;strong&gt;按位与运算&lt;/strong&gt;，就可以得到主机号。&lt;/p&gt;&#xA;&lt;p&gt;在寻址的过程中，先匹配到相同的网络号（表示要找到同一个子网），才会去找对应的主机。&lt;/p&gt;&#xA;&lt;p&gt;除了寻址能力， IP 协议还有另一个重要的能力就是&lt;strong&gt;路由&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。&lt;/p&gt;&#xA;&lt;p&gt;所以，IP协议的寻址作用是告诉我们去往下一个目的地该往哪个方向走，路由则是根据下一个目的地选择路径。寻址更像在导航，路由更像在操作方向盘。&lt;/p&gt;&#xA;&lt;h2 id=&#34;4-网络接口层&#34;&gt;&#xD;&#xA;  4. 网络接口层&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#4-%e7%bd%91%e7%bb%9c%e6%8e%a5%e5%8f%a3%e5%b1%82&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;生成了 IP 头部之后，接下来要交给网络接口层,在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。&lt;/p&gt;</description>
    </item>
    <item>
      <title>TCP篇</title>
      <link>https://xiaoli-lhx.github.io/%E8%AE%A1%E7%BD%91/tcp%E7%AF%87/tcp%E7%AF%87/</link>
      <pubDate>Sat, 23 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://xiaoli-lhx.github.io/%E8%AE%A1%E7%BD%91/tcp%E7%AF%87/tcp%E7%AF%87/</guid>
      <description>&lt;h1 id=&#34;udp与tcp协议&#34;&gt;&#xD;&#xA;  UDP与TCP协议&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#udp%e4%b8%8etcp%e5%8d%8f%e8%ae%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;udp协议&#34;&gt;&#xD;&#xA;  UDP协议&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#udp%e5%8d%8f%e8%ae%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;UDP（User Datagram Protocol，用户数据报协议）是一种无连接的传输层协议，它不保证数据可靠到达，也不保证数据顺序到达。它只提供一种简单的面向数据报的通信方式。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言中栈的实现：Slice还是List？</title>
      <link>https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%8B%9F%E6%A0%88/</link>
      <pubDate>Wed, 27 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%8B%9F%E6%A0%88/</guid>
      <description>&lt;h1 id=&#34;go语言中栈的实现slice还是list&#34;&gt;&#xD;&#xA;  Go语言中栈的实现：Slice还是List？&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#go%e8%af%ad%e8%a8%80%e4%b8%ad%e6%a0%88%e7%9a%84%e5%ae%9e%e7%8e%b0slice%e8%bf%98%e6%98%aflist&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;前言&#34;&gt;&#xD;&#xA;  前言&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%89%8d%e8%a8%80&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;在刷 LeetCode 题目「&#xD;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/&#34;&gt;LC1047. 删除字符串中的所有相邻重复项&lt;/a&gt;」时，我遇到了一个典型的栈应用场景。基于之前的学习，我首先使用 Go 的 &lt;code&gt;container/list&lt;/code&gt;（双向链表）来模拟栈，但发现执行效率并不理想。&#xA;&#xD;&#xA;  &lt;img src=&#34;https://xiaoli-lhx.github.io/images/go-stack.jpg&#34; alt=&#34;go-stack.jpg&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;在查阅了执行速度更快的解法后，我发现大家普遍使用 &lt;strong&gt;切片 (&lt;code&gt;slice&lt;/code&gt;)&lt;/strong&gt; 来模拟栈。这引发了我的思考：在 Go 语言中，实现栈时应该用 &lt;code&gt;container/list&lt;/code&gt; 还是切片？本文将探讨这两种方式的差异与优劣。&lt;/p&gt;&#xA;&lt;h2 id=&#34;两种实现方式的底层原理&#34;&gt;&#xD;&#xA;  两种实现方式的底层原理&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%a4%e7%a7%8d%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f%e7%9a%84%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;为了理解它们的差异，我们首先要了解两者在内存中的样子。&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-切片-slice---连续的盒子-&#34;&gt;&#xD;&#xA;  1. 切片 (Slice) - 连续的盒子 📦&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%e5%88%87%e7%89%87-slice---%e8%bf%9e%e7%bb%ad%e7%9a%84%e7%9b%92%e5%ad%90-&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;&lt;strong&gt;切片 (&lt;code&gt;slice&lt;/code&gt;)&lt;/strong&gt; 的本质是一个&lt;strong&gt;动态数组&lt;/strong&gt;，它的数据存放在一块&lt;strong&gt;连续的内存&lt;/strong&gt;中。就像一个有格子的长条盒子，所有元素都紧密地挨在一起。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// --- 用切片实现栈 ---&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt; = []&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;{}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 入栈&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 出栈&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt;[:len(&lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;2-containerlist---分散的车厢-&#34;&gt;&#xD;&#xA;  2. container/list - 分散的车厢 🚂&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2-containerlist---%e5%88%86%e6%95%a3%e7%9a%84%e8%bd%a6%e5%8e%a2-&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;container/list&lt;/code&gt;&lt;/strong&gt; 的本质是一个&lt;strong&gt;双向链表&lt;/strong&gt;。它的每个元素（节点）都是一个独立的对象，存放在内存中可能不连续的位置，通过指针相互连接。就像一串火车车厢，每个车厢都知道它的前后车厢是谁。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// --- 用 list 实现栈 ---&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;stackList&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;list&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;New&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 入栈&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;stackList&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;PushBack&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 出栈&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;stackList&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Remove&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;stackList&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Back&lt;/span&gt;())&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;核心对比性能与简洁度&#34;&gt;&#xD;&#xA;  核心对比：性能与简洁度&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%b8%e5%bf%83%e5%af%b9%e6%af%94%e6%80%a7%e8%83%bd%e4%b8%8e%e7%ae%80%e6%b4%81%e5%ba%a6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;性能对比为何切片通常更快&#34;&gt;&#xD;&#xA;  性能对比：为何切片通常更快？&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%80%a7%e8%83%bd%e5%af%b9%e6%af%94%e4%b8%ba%e4%bd%95%e5%88%87%e7%89%87%e9%80%9a%e5%b8%b8%e6%9b%b4%e5%bf%ab&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;理论上，两种方式的入栈和出栈操作时间复杂度都是 O(1)。但在实际运行中，&lt;strong&gt;切片通常性能更好&lt;/strong&gt;，这主要得益于“&lt;strong&gt;内存局部性&lt;/strong&gt;”（Memory Locality）。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
