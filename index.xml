<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog</title>
    <link>https://xiaoli-lhx.github.io/</link>
    <description>Recent content on Blog</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 07 Sep 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://xiaoli-lhx.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Gemini0905面试总结</title>
      <link>https://xiaoli-lhx.github.io/ai%E9%9D%A2%E8%AF%95/gemini0905/</link>
      <pubDate>Fri, 05 Sep 2025 00:00:00 +0000</pubDate>
      <guid>https://xiaoli-lhx.github.io/ai%E9%9D%A2%E8%AF%95/gemini0905/</guid>
      <description>&lt;h3 id=&#34;第一部分开场及综合素质考察&#34;&gt;&#xD;&#xA;  &lt;strong&gt;第一部分：开场及综合素质考察&lt;/strong&gt;&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac%e4%b8%80%e9%83%a8%e5%88%86%e5%bc%80%e5%9c%ba%e5%8f%8a%e7%bb%bc%e5%90%88%e7%b4%a0%e8%b4%a8%e8%80%83%e5%af%9f&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;&lt;strong&gt;1. 请用2-3分钟的时间做个自我介绍，重点讲讲你最引以为傲的技术亮点或项目。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;答：&lt;/p&gt;&#xA;&lt;p&gt;面试官您好，我叫李寒旭，是安徽农业大学计算机科学与技术专业的一名大四学生 。我非常热爱后端开发，求职意向是Go后端开发工程师 。&lt;/p&gt;&#xA;&lt;p&gt;在校期间，我系统学习了计算机网络、操作系统、数据结构等核心课程 ，并具备了扎实的理论基础。在技术实践上，我专注于Go语言技术栈，熟练掌握Go的并发编程 ，并熟悉Gin、GORM、Redis、Kafka等常用的框架和中间件 。&lt;/p&gt;&#xA;&lt;p&gt;我最引以为傲的是我独立设计并实现的&lt;strong&gt;分布式缓存系统MyCache&lt;/strong&gt; 。&lt;/p&gt;&#xA;&lt;p&gt;在这个项目中，我不仅仅是调用API，而是深入底层，亲手实现了一些核心组件。例如：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;为了提升缓存命中率，我实现了&lt;strong&gt;LRU/LRU-2缓存淘汰策略&lt;/strong&gt; 。&lt;/li&gt;&#xA;&lt;li&gt;为了保证系统的可扩展性，我设计并实现了带有&lt;strong&gt;虚拟节点的一致性哈希算法&lt;/strong&gt; 。&lt;/li&gt;&#xA;&lt;li&gt;为了应对高并发，我通过&lt;strong&gt;分段锁&lt;/strong&gt;减少锁竞争，并利用&lt;strong&gt;SingleFlight&lt;/strong&gt;机制防止缓存击穿 。&lt;/li&gt;&#xA;&lt;li&gt;最后，基于&lt;strong&gt;gRPC和etcd&lt;/strong&gt;实现了节点间的通信与服务发现 。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这个项目极大地锻炼了我的系统设计能力和编码能力。此外，我还主导开发了一个功能完善的&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;即时通讯项目MyChat&lt;/strong&gt; ，应用了WebSocket、Kafka和WebRTC等技术 。&lt;/p&gt;&#xA;&lt;p&gt;总的来说，我具备较强的学习能力和动手能力，注重代码质量和系统性能 ，希望能有机会加入贵公司，为团队贡献自己的力量。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;2. 你的求职意向是后端开发工程师，是什么吸引你选择这个方向？&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;答：&lt;/p&gt;&#xA;&lt;p&gt;主要有三点吸引我：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;成就感&lt;/strong&gt;：后端是整个应用的核心，负责处理复杂的业务逻辑、管理数据、并保证系统的高性能和高可用。能够从0到1构建一个稳定、高效的系统，并为前端提供强大的支持，这让我有很大的成就感。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;技术深度&lt;/strong&gt;：后端领域技术栈非常深，从编程语言、数据库、缓存、消息队列到底层的网络协议和操作系统，有大量值得深入研究的知识。我非常享受这种不断钻研、解决复杂技术挑战的过程。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;对Go语言的热爱&lt;/strong&gt;：我非常喜欢Go语言，它的简洁、高效以及天生的并发优势让我着迷。Go语言在云原生和微服务领域的广泛应用，也让我看到了后端开发的广阔前景。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;3. 看你的教育背景，你认为在大学期间，哪门课程对你现在从事后端开发帮助最大？为什么？&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;答：&lt;/p&gt;&#xA;&lt;p&gt;我认为是《计算机网络》和《数据结构与算法》这两门课程。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;《计算机网络》&lt;/strong&gt; 让我理解了数据是如何在不同主机之间传输的。学习TCP/IP、HTTP等协议让我明白了Web服务的底层原理。比如在开发MyChat项目时，对WebSocket和HTTP协议的理解帮助我更好地设计通信方案；在开发MyCache时，对TCP和gRPC的理解是实现节点间高效通信的基础。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;《数据结构与算法》&lt;/strong&gt; 则是编程的内功。比如，在MyCache项目中，我独立实现了LRU缓存淘汰算法和一致性哈希算法，这些都直接来源于这门课程的知识。扎实的数据结构基础让我能写出更高效、更健壮的代码。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;4. 你在简历中提到了一个省级计算机博弈大赛的奖项，可以简单介绍一下这个比赛和你的作品吗？你在团队中扮演了什么角色？&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;答：&lt;/p&gt;&#xA;&lt;p&gt;好的。安徽省大学生计算机博弈大赛 是一个智能博弈的竞赛，要求我们编写AI程序，在某个棋类或牌类游戏中与其他队伍的程序进行对战。我们当时选择的是一个叫做“六子棋”的棋类游戏。&lt;/p&gt;&#xA;&lt;p&gt;在这个项目中，我主要担任&lt;strong&gt;核心算法开发&lt;/strong&gt;的角色。我的工作包括：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;设计棋局评估函数&lt;/strong&gt;：我设计了一个函数，它可以根据当前的棋盘状态（比如连子数、活子数、关键位置占用等）给出一个分数，用于判断当前局面对谁更有利。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;实现博弈树搜索算法&lt;/strong&gt;：我实现了基于Alpha-Beta剪枝的极小极大搜索算法，让AI可以“思考”未来几步的走法，并选择对自己最有利的一步。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;性能优化&lt;/strong&gt;：由于比赛有严格的时间限制，我花了很多时间优化算法的性能，比如使用置换表来缓存已经计算过的棋局状态，减少重复搜索。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;这个经历不仅锻炼了我的算法设计和实现能力，也让我深刻理解了性能优化的重要性。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;5. 除了简历上提到的技术，你最近还在关注或学习哪些新的技术？你是如何进行技术学习的？&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;答：&lt;/p&gt;&#xA;&lt;p&gt;除了简历上的技术栈，我最近在重点关注和学习以下几个方面：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;云原生相关技术&lt;/strong&gt;：特别是Kubernetes。我目前已经掌握了Docker的基础使用，下一步计划是深入学习K8s的架构、核心组件（如Pod, Service, Deployment）以及它的工作原理，因为我认为容器编排是现代后端开发的必备技能。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;可观测性（Observability）&lt;/strong&gt;：我在学习Prometheus和Grafana，希望了解如何对一个分布式系统进行有效的监控、告警和链路追踪，从而能更快地定位和解决线上问题。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;我的学习方法主要是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;官方文档优先&lt;/strong&gt;：对于一门新技术，我倾向于首先阅读官方文档，建立一个系统性的认知。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;项目驱动&lt;/strong&gt;：学习理论后，我会立刻通过一个小的实践项目来应用它。就像我为了深入理解分布式系统而做了MyCache项目一样，实践是检验和巩固知识最好的方式。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;阅读优秀源码&lt;/strong&gt;：我会去阅读一些知名开源项目（比如Gin、Etcd）的源码，学习它们的设计思想和优秀实践。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;关注社区和博客&lt;/strong&gt;：我经常在GitHub 、技术博客和开发者社区上关注行业动态和前沿技术。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;第二部分技术基础与理论知识考察&#34;&gt;&#xD;&#xA;  &lt;strong&gt;第二部分：技术基础与理论知识考察&lt;/strong&gt;&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac%e4%ba%8c%e9%83%a8%e5%88%86%e6%8a%80%e6%9c%af%e5%9f%ba%e7%a1%80%e4%b8%8e%e7%90%86%e8%ae%ba%e7%9f%a5%e8%af%86%e8%80%83%e5%af%9f&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;h4 id=&#34;编程语言-go&#34;&gt;&#xD;&#xA;  &lt;strong&gt;编程语言 (Go)&lt;/strong&gt;&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80-go&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;&lt;strong&gt;1. 你提到熟练掌握Go语言，能谈谈你对Go语言并发编程的理解吗？Goroutine和线程（Thread）有什么区别和优势？&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言基础</title>
      <link>https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 26 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E5%9F%BA%E7%A1%80/</guid>
      <description>&lt;h1 id=&#34;go语言基础&#34;&gt;&#xD;&#xA;  Go语言基础&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#go%e8%af%ad%e8%a8%80%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;8.26 已完成：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; go的特点与优势&lt;/li&gt;&#xA;&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 包管理&lt;/li&gt;&#xA;&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 实现重载&lt;/li&gt;&#xA;&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 实现继承&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;TODO：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 实现多态&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 切片与数组区别&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; slice相关&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; struct与class&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 错误处理机制&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;1-和java对比介绍一下go语言的优势和特点&#34;&gt;&#xD;&#xA;  1. 和Java对比，介绍一下go语言的优势和特点&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%e5%92%8cjava%e5%af%b9%e6%af%94%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8bgo%e8%af%ad%e8%a8%80%e7%9a%84%e4%bc%98%e5%8a%bf%e5%92%8c%e7%89%b9%e7%82%b9&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;&lt;strong&gt;考点&lt;/strong&gt;：对编程语言的理解&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;难度&lt;/strong&gt;：简单&lt;/p&gt;&#xA;&lt;p&gt;总的来说，Go语言在性能、并发处理、部署和开发效率上都有其独特的优势，尤其适合网络服务和云计算领域&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;语法简洁：Go语言的语法非常简洁，没有类和继承等概念，代码易于维护和读写&lt;/li&gt;&#xA;&lt;li&gt;编译型语言：Go语言是一种编译型语言，编译成机器码直接运行，且编译速度很快&lt;/li&gt;&#xA;&lt;li&gt;高性能：Go语言的执行速度接近于C/C++，速度比Java快&lt;/li&gt;&#xA;&lt;li&gt;并发支持：Go语言的并发模型是基于&lt;code&gt;goroutine&lt;/code&gt;和&lt;code&gt;channel&lt;/code&gt;，使得并发编程变的简单高效，而Java的多线程模型相对较为复杂一些&lt;/li&gt;&#xA;&lt;li&gt;内存管理：Go语言拥有自己的垃圾回收机制，简化了内存管理&lt;/li&gt;&#xA;&lt;li&gt;部署简单：Go程序编译后生成单一的可执行文件，部署非常简单&lt;/li&gt;&#xA;&lt;li&gt;标准库丰富：Go拥有高质量的标准库，涵盖网络、加密、数据结构等方面&lt;/li&gt;&#xA;&lt;li&gt;工具链：Go有一套强大的工具链，如用于格式化代码的&lt;code&gt;gofmt&lt;/code&gt;、用于性能分析的&lt;code&gt;pprof&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;静态类型：Go是静态类型语言，有助于在编译时捕捉错误&lt;/li&gt;&#xA;&lt;li&gt;跨平台编译：Go支持跨平台编译，可以很方便地为不同操作系统构建应用程序&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;2-go包管理的方式有哪些&#34;&gt;&#xD;&#xA;  2. go包管理的方式有哪些？&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2-go%e5%8c%85%e7%ae%a1%e7%90%86%e7%9a%84%e6%96%b9%e5%bc%8f%e6%9c%89%e5%93%aa%e4%ba%9b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;&lt;strong&gt;考点&lt;/strong&gt;：包管理&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;难度&lt;/strong&gt;：简单&lt;/p&gt;&#xA;&lt;p&gt;Go语言的包管理最开始是&lt;code&gt;GOPATH&lt;/code&gt;的方式，每个项目都需要放在&lt;code&gt;GOPATH&lt;/code&gt;的下面，Go会从&lt;code&gt;GOPATH&lt;/code&gt;的&lt;code&gt;src&lt;/code&gt;目录寻找所有的包。&lt;/p&gt;&#xA;&lt;p&gt;现在主要用&lt;code&gt;Go Modules&lt;/code&gt;，官方从1.11版本开始引入，成了官方推荐的包管理方式。不再依赖&lt;code&gt;GOPATH&lt;/code&gt;,可以直接在任何地方创建项目，通过&lt;code&gt;go.mod&lt;/code&gt;文件来管理依赖。&lt;/p&gt;&#xA;&lt;h2 id=&#34;3-go支持重载吗如何在go中实现一个方法的重载&#34;&gt;&#xD;&#xA;  3. Go支持重载吗？如何在Go中实现一个方法的&amp;quot;重载&amp;quot;？&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#3-go%e6%94%af%e6%8c%81%e9%87%8d%e8%bd%bd%e5%90%97%e5%a6%82%e4%bd%95%e5%9c%a8go%e4%b8%ad%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e6%96%b9%e6%b3%95%e7%9a%84%e9%87%8d%e8%bd%bd&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;&lt;strong&gt;考点&lt;/strong&gt;：方法重载&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;难度&lt;/strong&gt;：中等&lt;/p&gt;&#xA;&lt;p&gt;Go 不支持函数/方法的重载，你&lt;strong&gt;不能在同一个作用域中定义多个函数名相同但参数不同的函数&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;会报编译错误：&lt;strong&gt;“（function name） redeclared in this block”&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;可以通过以下方式&lt;strong&gt;模拟&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用接口+类型断言&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Add&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt;{}) &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt;{} {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;switch&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;aVal&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;.(&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bVal&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;);&lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;aVal&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;bVal&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;float64&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bVal&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.(&lt;span style=&#34;color:#66d9ef&#34;&gt;float64&lt;/span&gt;);&lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;aVal&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;bVal&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;使用组合+接口&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;不同的方法封装在不同的嵌套结构中，外部选择性调用这些方法&lt;/p&gt;</description>
    </item>
    <item>
      <title>TCP/IP网络模型有哪几层？</title>
      <link>https://xiaoli-lhx.github.io/%E8%AE%A1%E7%BD%91/%E5%9F%BA%E7%A1%80%E7%AF%87/tcp_ip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E5%B1%82/</link>
      <pubDate>Sun, 24 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://xiaoli-lhx.github.io/%E8%AE%A1%E7%BD%91/%E5%9F%BA%E7%A1%80%E7%AF%87/tcp_ip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E5%B1%82/</guid>
      <description>&lt;h1 id=&#34;tcpip网络模型有哪几层&#34;&gt;&#xD;&#xA;  TCP/IP网络模型有哪几层？&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#tcpip%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b%e6%9c%89%e5%93%aa%e5%87%a0%e5%b1%82&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;1-应用层&#34;&gt;&#xD;&#xA;  1. 应用层&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%e5%ba%94%e7%94%a8%e5%b1%82&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;最上层的，也是我们能直接接触到的就是&lt;strong&gt;应用层&lt;/strong&gt;（&lt;em&gt;Application Layer&lt;/em&gt;）,应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。应用层是不用去关心数据是如何传输的,应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-传输层&#34;&gt;&#xD;&#xA;  2. 传输层&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2-%e4%bc%a0%e8%be%93%e5%b1%82&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;应用层的数据包会传给传输层，&lt;strong&gt;传输层&lt;/strong&gt;（&lt;em&gt;Transport Layer&lt;/em&gt;）是为应用层提供网络支持的。&lt;/p&gt;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;script src=&#34;https://xiaoli-lhx.github.io/mermaid.min.js&#34;&gt;&lt;/script&gt;&#xD;&#xA;&#xD;&#xA;  &lt;script&gt;mermaid.initialize({&#xD;&#xA;  &#34;flowchart&#34;: {&#xD;&#xA;    &#34;useMaxWidth&#34;:true&#xD;&#xA;  },&#xD;&#xA;  &#34;theme&#34;: &#34;default&#34;&#xD;&#xA;}&#xD;&#xA;)&lt;/script&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;pre class=&#34;mermaid&#34;&gt;flowchart BT&#xD;&#xA;    传输层--&amp;gt;应用层A&#xD;&#xA;&#x9;传输层--&amp;gt;应用层B&lt;/pre&gt;&#xD;&#xA;&lt;p&gt;在传输层会有两个传输协议，分别是 &lt;code&gt;TCP&lt;/code&gt;和&lt;code&gt; UDP&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;TCP 的全称叫传输控制协议,TCP比&lt;code&gt;UDP&lt;/code&gt;多了很多特性，比如流量控制，超时重传，拥塞控制等,这些都是为了保证数据包能可靠的传输给对方。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;UDP&lt;/code&gt;相对来说很简单，简单到只负责发送数据包，不保证数据包能抵达对方，但他的实时性相对更好，传输效率也高&lt;/p&gt;&#xA;&lt;p&gt;当传输层的数据包大小超过&lt;code&gt;MSS&lt;/code&gt;(TCP 最大报文段长度)，就需要将数据包分块，这样即使中途有一个分块丢失或者损坏，只需要重新发送这一个分块，而不需要发送整个数据包。在TCP协议中，我们把每个分块成为一个TCP段&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;端口&lt;/strong&gt;：当设备作为接收方时，传输层则要负责把数据包传给应用，但一台设备可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用去分开来，这个编号就是端口。&lt;/p&gt;&#xA;&lt;p&gt;由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。&lt;/p&gt;&#xA;&lt;h2 id=&#34;3-网络层&#34;&gt;&#xD;&#xA;  3. 网络层&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#3-%e7%bd%91%e7%bb%9c%e5%b1%82&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;pre class=&#34;mermaid&#34;&gt;flowchart BT&#xD;&#xA;    网络层--&amp;gt;传输层A--&amp;gt;应用层A&#xD;&#xA;&#x9;网络层--&amp;gt;传输层B--&amp;gt;应用层B&lt;/pre&gt;&#xD;&#xA;&lt;p&gt;网络层最常使用的时IP协议，IP协议会将传输层的报文作为数据部分，再加上IP报头组成IP报文，如果IP报文大小超过MTU（以太网中一般为1500字节）就会再次进行分片，得到一个即将发送到网络的IP报文。&lt;/p&gt;&#xA;&lt;p&gt;网络层负责将数据从一个设备传输到另一个设备。&lt;/p&gt;&#xA;&lt;p&gt;需要将 IP 地址分成两种意义：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个是&lt;strong&gt;网络号&lt;/strong&gt;，负责标识该 IP 地址是属于哪个「子网」的；&lt;/li&gt;&#xA;&lt;li&gt;一个是&lt;strong&gt;主机号&lt;/strong&gt;，负责标识同一「子网」下的不同主机；&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这需要配合&lt;strong&gt;子网掩码&lt;/strong&gt;才能算出 IP 地址 的网络号和主机号。&lt;/p&gt;&#xA;&lt;p&gt;将IP地址与子网掩码&lt;strong&gt;按位与运算&lt;/strong&gt;，就可以得到网络号。&lt;/p&gt;&#xA;&lt;p&gt;将子网掩码取反后与IP地址进行进行&lt;strong&gt;按位与运算&lt;/strong&gt;，就可以得到主机号。&lt;/p&gt;&#xA;&lt;p&gt;在寻址的过程中，先匹配到相同的网络号（表示要找到同一个子网），才会去找对应的主机。&lt;/p&gt;&#xA;&lt;p&gt;除了寻址能力， IP 协议还有另一个重要的能力就是&lt;strong&gt;路由&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。&lt;/p&gt;&#xA;&lt;p&gt;所以，IP协议的寻址作用是告诉我们去往下一个目的地该往哪个方向走，路由则是根据下一个目的地选择路径。寻址更像在导航，路由更像在操作方向盘。&lt;/p&gt;&#xA;&lt;h2 id=&#34;4-网络接口层&#34;&gt;&#xD;&#xA;  4. 网络接口层&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#4-%e7%bd%91%e7%bb%9c%e6%8e%a5%e5%8f%a3%e5%b1%82&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;生成了 IP 头部之后，接下来要交给网络接口层,在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。&lt;/p&gt;</description>
    </item>
    <item>
      <title>TCP篇</title>
      <link>https://xiaoli-lhx.github.io/%E8%AE%A1%E7%BD%91/tcp%E7%AF%87/tcp%E7%AF%87/</link>
      <pubDate>Sat, 23 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://xiaoli-lhx.github.io/%E8%AE%A1%E7%BD%91/tcp%E7%AF%87/tcp%E7%AF%87/</guid>
      <description>&lt;h1 id=&#34;udp与tcp协议&#34;&gt;&#xD;&#xA;  UDP与TCP协议&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#udp%e4%b8%8etcp%e5%8d%8f%e8%ae%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;udp协议&#34;&gt;&#xD;&#xA;  UDP协议&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#udp%e5%8d%8f%e8%ae%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;UDP（User Datagram Protocol，用户数据报协议）是一种无连接的传输层协议，它不保证数据可靠到达，也不保证数据顺序到达。它只提供一种简单的面向数据报的通信方式。&lt;/p&gt;</description>
    </item>
    <item>
      <title>MyCache项目面试问题</title>
      <link>https://xiaoli-lhx.github.io/ai%E9%9D%A2%E8%AF%95/mycache/</link>
      <pubDate>Sun, 07 Sep 2025 00:00:00 +0000</pubDate>
      <guid>https://xiaoli-lhx.github.io/ai%E9%9D%A2%E8%AF%95/mycache/</guid>
      <description>&lt;h1 id=&#34;mycache项目面试问题&#34;&gt;&#xD;&#xA;  MyCache项目面试问题&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mycache%e9%a1%b9%e7%9b%ae%e9%9d%a2%e8%af%95%e9%97%ae%e9%a2%98&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;1-简历写法&#34;&gt;&#xD;&#xA;  1. 简历写法&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%e7%ae%80%e5%8e%86%e5%86%99%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;&#xD;&#xA;  &lt;img src=&#34;https://xiaoli-lhx.github.io/images/MyCache.jpg&#34; alt=&#34;MyCache&#34; /&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-常见面试题目&#34;&gt;&#xD;&#xA;  2. 常见面试题目&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2-%e5%b8%b8%e8%a7%81%e9%9d%a2%e8%af%95%e9%a2%98%e7%9b%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;1什么是缓存&#34;&gt;&#xD;&#xA;  1.什么是缓存&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1%e4%bb%80%e4%b9%88%e6%98%af%e7%bc%93%e5%ad%98&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;答：缓存，就是数据交换的缓冲区，是一种用于临时存储数据的高效存储机制，其主要目的是加快访问速度、减轻后台系统压力，从而提升整体性能。我们平时说的缓存大多是指内存。目的是，把读写速度慢的介质的数据保存在读写速度快的介质（快慢是相对的），从而提高读写速度，减少时间消耗。例如：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CPU告诉缓存：高速缓存的读写速度远高于内存。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CPU读数据时，如果在高速缓存中找到所需数据，就不需要读内存&lt;/li&gt;&#xA;&lt;li&gt;CPU写数据时，先写到高速缓存，再写回内存。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;磁盘缓存：磁盘缓存其实就是把常用的磁盘数据保存在内存中，内存读写速度也是远高于磁盘的。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;读数据时从内存中读取。&lt;/li&gt;&#xA;&lt;li&gt;写数据时，可先写回内存，定时或定量写回到磁盘，或者时同步写回&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;2请说说有那些缓存算法是否能手写一下lru代码的实现&#34;&gt;&#xD;&#xA;  2.请说说有那些缓存算法？是否能手写一下LRU代码的实现？&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2%e8%af%b7%e8%af%b4%e8%af%b4%e6%9c%89%e9%82%a3%e4%ba%9b%e7%bc%93%e5%ad%98%e7%ae%97%e6%b3%95%e6%98%af%e5%90%a6%e8%83%bd%e6%89%8b%e5%86%99%e4%b8%80%e4%b8%8blru%e4%bb%a3%e7%a0%81%e7%9a%84%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;缓存算法中，比较常见的如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;FIFO（先进先出）&lt;/li&gt;&#xA;&lt;li&gt;LRU（最近最少使用）&lt;/li&gt;&#xA;&lt;li&gt;LFU（最不经常使用）&lt;/li&gt;&#xA;&lt;li&gt;ARC（自适应替换）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;LRU代码实现如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;container/list&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LRUCache&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;cap&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;cache&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;list&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Element&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;list&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;list&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;List&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;entry&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;NewLRUCache&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;capacity&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;LRUCache&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;LRUCache&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;cap&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;capacity&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;cache&lt;/span&gt;: make(&lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;list&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Element&lt;/span&gt;),&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;list&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;list&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;New&lt;/span&gt;(),&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;LRUCache&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;Get&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ele&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;cache&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt;]; &lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;list&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;MoveToFront&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;ele&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ele&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Value&lt;/span&gt;.(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;entry&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;LRUCache&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;Put&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ele&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;cache&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt;]; &lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;list&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;MoveToFront&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;ele&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;ele&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Value&lt;/span&gt;.(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;entry&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;cache&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;cap&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;old&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;list&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Back&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;list&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Remove&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;old&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;delete(&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;cache&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;old&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Value&lt;/span&gt;.(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;entry&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;ele&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;list&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;PushFront&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;entry&lt;/span&gt;{&lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;})&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;cache&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt;] = &lt;span style=&#34;color:#a6e22e&#34;&gt;ele&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;cache&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;NewLRUCache&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;cache&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Put&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;cache&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Put&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cache&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Get&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)) &lt;span style=&#34;color:#75715e&#34;&gt;// Output: 1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;cache&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Put&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cache&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Get&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)) &lt;span style=&#34;color:#75715e&#34;&gt;// Output: -1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cache&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Get&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)) &lt;span style=&#34;color:#75715e&#34;&gt;// Output: 3&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;cache&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Put&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cache&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Get&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)) &lt;span style=&#34;color:#75715e&#34;&gt;// Output: -1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cache&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Get&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)) &lt;span style=&#34;color:#75715e&#34;&gt;// Output: 3&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;cache&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Get&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;)) &lt;span style=&#34;color:#75715e&#34;&gt;// Output: 4&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;&#xA;&lt;h3 id=&#34;3-为什么需要实现这个项目使用缓存的目标是什么&#34;&gt;&#xD;&#xA;  3. 为什么需要实现这个项目？使用缓存的目标是什么？&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#3-%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%ae%9e%e7%8e%b0%e8%bf%99%e4%b8%aa%e9%a1%b9%e7%9b%ae%e4%bd%bf%e7%94%a8%e7%bc%93%e5%ad%98%e7%9a%84%e7%9b%ae%e6%a0%87%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;：阐述高并发场景下缓存的意义，例如提升性能、降低数据库压力、优化用户体验等。&lt;/p&gt;</description>
    </item>
    <item>
      <title>在浏览器中输入URL并按下回车之和会发生什么</title>
      <link>https://xiaoli-lhx.github.io/%E8%AE%A1%E7%BD%91/%E5%9F%BA%E7%A1%80%E7%AF%87/url_about/</link>
      <pubDate>Mon, 01 Sep 2025 00:00:00 +0000</pubDate>
      <guid>https://xiaoli-lhx.github.io/%E8%AE%A1%E7%BD%91/%E5%9F%BA%E7%A1%80%E7%AF%87/url_about/</guid>
      <description>&lt;h1 id=&#34;在浏览器中输入url并按下回车之和会发生什么&#34;&gt;&#xD;&#xA;  在浏览器中输入URL并按下回车之和会发生什么&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9c%a8%e6%b5%8f%e8%a7%88%e5%99%a8%e4%b8%ad%e8%be%93%e5%85%a5url%e5%b9%b6%e6%8c%89%e4%b8%8b%e5%9b%9e%e8%bd%a6%e4%b9%8b%e5%92%8c%e4%bc%9a%e5%8f%91%e7%94%9f%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;1-输入url并解析&#34;&gt;&#xD;&#xA;  1. 输入URL并解析&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%e8%be%93%e5%85%a5url%e5%b9%b6%e8%a7%a3%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;输入&lt;code&gt;URL&lt;/code&gt;后，浏览器会解析出协议、主机、端口、路径等信息，并构造一个HTTP请求（浏览器会根据请求头判断是否有&lt;code&gt;HTTP缓存&lt;/code&gt;，并根据是否有缓存决定是从服务器获取资源还是使用缓存资源）&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-dns域名解析将域名解析成对应的ip地址&#34;&gt;&#xD;&#xA;  2. DNS域名解析，将域名解析成对应的IP地址&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2-dns%e5%9f%9f%e5%90%8d%e8%a7%a3%e6%9e%90%e5%b0%86%e5%9f%9f%e5%90%8d%e8%a7%a3%e6%9e%90%e6%88%90%e5%af%b9%e5%ba%94%e7%9a%84ip%e5%9c%b0%e5%9d%80&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;在发送HTTP请求之前，浏览器需要知道想要访问网页对应的IP地址，这就需要使用到&lt;code&gt;DNS域名解析&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;3-建立起tcp连接之三次握手&#34;&gt;&#xD;&#xA;  3. 建立起TCP连接之三次握手&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#3-%e5%bb%ba%e7%ab%8b%e8%b5%b7tcp%e8%bf%9e%e6%8e%a5%e4%b9%8b%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&#xD;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xD;&#xA;  &lt;p&gt;这里可以拓展很多，比如为什么是三次，不是两次、四次？如果第一次握手丢失了会发生什么？三次握手过程中可以携带数据吗？&lt;/p&gt;&#xD;&#xA;&lt;/blockquote&gt;&lt;p&gt;客户端和服务器之间进行HTTP请求和HTTP响应的过程中，需要建立起TCP连接，TCP连接需要进行三次握手&lt;/p&gt;&#xA;&lt;h2 id=&#34;4-浏览器发送httphttps请求到web服务器&#34;&gt;&#xD;&#xA;  4. 浏览器发送HTTP/HTTPS请求到web服务器&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#4-%e6%b5%8f%e8%a7%88%e5%99%a8%e5%8f%91%e9%80%81httphttps%e8%af%b7%e6%b1%82%e5%88%b0web%e6%9c%8d%e5%8a%a1%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&#xD;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xD;&#xA;  &lt;p&gt;扩展问题比如HTTP/HTTPS的区别？请求的方式？请求的状态码等和HTTP请求的问题&lt;/p&gt;&#xD;&#xA;&lt;/blockquote&gt;&lt;h2 id=&#34;5-服务器处理http请求并返回http报文&#34;&gt;&#xD;&#xA;  5. 服务器处理HTTP请求并返回HTTP报文&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#5-%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%a4%84%e7%90%86http%e8%af%b7%e6%b1%82%e5%b9%b6%e8%bf%94%e5%9b%9ehttp%e6%8a%a5%e6%96%87&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;服务器会接受请求并将其传递给请求处理程序并发送HTTP响应，一般响应报文包含：请求的网页以及状态码，压缩类型，如何缓存的页面，设置的cookie；&lt;/p&gt;&#xA;&lt;h2 id=&#34;6-浏览器渲染页面&#34;&gt;&#xD;&#xA;  6. 浏览器渲染页面&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#6-%e6%b5%8f%e8%a7%88%e5%99%a8%e6%b8%b2%e6%9f%93%e9%a1%b5%e9%9d%a2&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h2 id=&#34;7-断开连接之tcp四次挥手&#34;&gt;&#xD;&#xA;  7. 断开连接之TCP四次挥手&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#7-%e6%96%ad%e5%bc%80%e8%bf%9e%e6%8e%a5%e4%b9%8btcp%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&#xD;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xD;&#xA;  &lt;p&gt;四次挥手的过程，为什么是四次？&lt;/p&gt;&#xD;&#xA;&lt;/blockquote&gt;&lt;p&gt;客户端和服务器之间断开连接需要进行四次挥手&lt;/p&gt;&#xA;&lt;h1 id=&#34;dns&#34;&gt;&#xD;&#xA;  DNS&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#dns&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;</description>
    </item>
    <item>
      <title>Go语言中栈的实现：Slice还是List？</title>
      <link>https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%8B%9F%E6%A0%88/</link>
      <pubDate>Wed, 27 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%8B%9F%E6%A0%88/</guid>
      <description>&lt;h1 id=&#34;go语言中栈的实现slice还是list&#34;&gt;&#xD;&#xA;  Go语言中栈的实现：Slice还是List？&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#go%e8%af%ad%e8%a8%80%e4%b8%ad%e6%a0%88%e7%9a%84%e5%ae%9e%e7%8e%b0slice%e8%bf%98%e6%98%aflist&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;前言&#34;&gt;&#xD;&#xA;  前言&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%89%8d%e8%a8%80&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;在刷 LeetCode 题目「&#xD;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/&#34;&gt;LC1047. 删除字符串中的所有相邻重复项&lt;/a&gt;」时，我遇到了一个典型的栈应用场景。基于之前的学习，我首先使用 Go 的 &lt;code&gt;container/list&lt;/code&gt;（双向链表）来模拟栈，但发现执行效率并不理想。&#xA;&#xD;&#xA;  &lt;img src=&#34;https://xiaoli-lhx.github.io/images/go-stack.jpg&#34; alt=&#34;go-stack.jpg&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;在查阅了执行速度更快的解法后，我发现大家普遍使用 &lt;strong&gt;切片 (&lt;code&gt;slice&lt;/code&gt;)&lt;/strong&gt; 来模拟栈。这引发了我的思考：在 Go 语言中，实现栈时应该用 &lt;code&gt;container/list&lt;/code&gt; 还是切片？本文将探讨这两种方式的差异与优劣。&lt;/p&gt;&#xA;&lt;h2 id=&#34;两种实现方式的底层原理&#34;&gt;&#xD;&#xA;  两种实现方式的底层原理&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%a4%e7%a7%8d%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f%e7%9a%84%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;为了理解它们的差异，我们首先要了解两者在内存中的样子。&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-切片-slice---连续的盒子-&#34;&gt;&#xD;&#xA;  1. 切片 (Slice) - 连续的盒子 📦&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%e5%88%87%e7%89%87-slice---%e8%bf%9e%e7%bb%ad%e7%9a%84%e7%9b%92%e5%ad%90-&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;&lt;strong&gt;切片 (&lt;code&gt;slice&lt;/code&gt;)&lt;/strong&gt; 的本质是一个&lt;strong&gt;动态数组&lt;/strong&gt;，它的数据存放在一块&lt;strong&gt;连续的内存&lt;/strong&gt;中。就像一个有格子的长条盒子，所有元素都紧密地挨在一起。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// --- 用切片实现栈 ---&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt; = []&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;{}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 入栈&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 出栈&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt;[:len(&lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;2-containerlist---分散的车厢-&#34;&gt;&#xD;&#xA;  2. container/list - 分散的车厢 🚂&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2-containerlist---%e5%88%86%e6%95%a3%e7%9a%84%e8%bd%a6%e5%8e%a2-&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;container/list&lt;/code&gt;&lt;/strong&gt; 的本质是一个&lt;strong&gt;双向链表&lt;/strong&gt;。它的每个元素（节点）都是一个独立的对象，存放在内存中可能不连续的位置，通过指针相互连接。就像一串火车车厢，每个车厢都知道它的前后车厢是谁。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// --- 用 list 实现栈 ---&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;stackList&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;list&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;New&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 入栈&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;stackList&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;PushBack&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 出栈&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;stackList&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Remove&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;stackList&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Back&lt;/span&gt;())&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;核心对比性能与简洁度&#34;&gt;&#xD;&#xA;  核心对比：性能与简洁度&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%b8%e5%bf%83%e5%af%b9%e6%af%94%e6%80%a7%e8%83%bd%e4%b8%8e%e7%ae%80%e6%b4%81%e5%ba%a6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;性能对比为何切片通常更快&#34;&gt;&#xD;&#xA;  性能对比：为何切片通常更快？&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%80%a7%e8%83%bd%e5%af%b9%e6%af%94%e4%b8%ba%e4%bd%95%e5%88%87%e7%89%87%e9%80%9a%e5%b8%b8%e6%9b%b4%e5%bf%ab&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;理论上，两种方式的入栈和出栈操作时间复杂度都是 O(1)。但在实际运行中，&lt;strong&gt;切片通常性能更好&lt;/strong&gt;，这主要得益于“&lt;strong&gt;内存局部性&lt;/strong&gt;”（Memory Locality）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 语言解「前 K 个高频元素」：从排序到堆的深度探索</title>
      <link>https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E8%AF%AD%E8%A8%80%E5%A0%86/</link>
      <pubDate>Sun, 31 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E8%AF%AD%E8%A8%80%E5%A0%86/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;&#xD;&#xA;  前言&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%89%8d%e8%a8%80&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;最近在刷 LeetCode 时，遇到了一道非常经典的题目：「&#xD;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/top-k-frequent-elements/&#34;&gt;347. 前 K 个高频元素&lt;/a&gt;」。这道题不仅考察了基本的数据处理能力，更引出了一些关于排序和更高级数据结构的深度思考。&lt;/p&gt;&#xA;&lt;p&gt;我的第一反应是，这需要分两步走：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;统计每个元素出现的频率。&lt;/li&gt;&#xA;&lt;li&gt;找出频率最高的 k 个元素。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;第一步用哈希表（&lt;code&gt;map&lt;/code&gt;）解决非常直观，但第二步“如何找出最高频的k个”则引出了几种不同的实现方式和性能考量。这篇博客记录了我从最直观的“排序”解法，到更高效的“堆”解法的完整思考过程。&lt;/p&gt;&#xA;&lt;h2 id=&#34;思路一哈希表--排序-直观解法&#34;&gt;&#xD;&#xA;  思路一：哈希表 + 排序 (直观解法)&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%80%9d%e8%b7%af%e4%b8%80%e5%93%88%e5%b8%8c%e8%a1%a8--%e6%8e%92%e5%ba%8f-%e7%9b%b4%e8%a7%82%e8%a7%a3%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;这是我最先想到的方法，思路清晰，容易理解。&lt;/p&gt;&#xA;&lt;h3 id=&#34;核心思路&#34;&gt;&#xD;&#xA;  核心思路&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;统计频率&lt;/strong&gt;：遍历一遍数组，用一个 &lt;code&gt;map[int]int&lt;/code&gt; 来存储每个数字及其出现的次数。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;转换结构&lt;/strong&gt;：将 &lt;code&gt;map&lt;/code&gt; 中的键值对转换到一个结构体切片中，每个结构体包含 &lt;code&gt;Number&lt;/code&gt; 和 &lt;code&gt;Count&lt;/code&gt; 两个字段。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;排序&lt;/strong&gt;：对该切片按照 &lt;code&gt;Count&lt;/code&gt; 字段进行&lt;strong&gt;降序&lt;/strong&gt;排序。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;取值&lt;/strong&gt;：取出排序后切片的前 &lt;code&gt;k&lt;/code&gt; 个元素，即为所求。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;实现难点go-的自定义排序-sortslice&#34;&gt;&#xD;&#xA;  实现难点：Go 的自定义排序 &lt;code&gt;sort.Slice&lt;/code&gt;&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%9e%e7%8e%b0%e9%9a%be%e7%82%b9go-%e7%9a%84%e8%87%aa%e5%ae%9a%e4%b9%89%e6%8e%92%e5%ba%8f-sortslice&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;在第三步中，我们需要对一个自定义的结构体切片进行排序。Go 的 &lt;code&gt;sort&lt;/code&gt; 包提供了一个非常强大的函数 &lt;code&gt;sort.Slice&lt;/code&gt;，它允许我们提供一个自定义的“比较函数”来定义排序规则。&lt;/p&gt;&#xA;&lt;p&gt;对于降序排序，我们的规则是：&lt;strong&gt;如果元素 i 的次数大于元素 j 的次数，那么 i 就应该排在 j 的前面&lt;/strong&gt;。这个规则就通过&lt;code&gt;Less&lt;/code&gt;函数告诉&lt;code&gt;sort.Slice&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;go-代码实现&#34;&gt;&#xD;&#xA;  Go 代码实现&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#go-%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sort&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;topKFrequent_Sort&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;nums&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;k&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 1. 统计频率&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;freqMap&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make(&lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;num&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;nums&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;freqMap&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;num&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 2. 将 map 转换为 struct 切片&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Pair&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;Number&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;Count&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;pairs&lt;/span&gt; []&lt;span style=&#34;color:#a6e22e&#34;&gt;Pair&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;num&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;freqMap&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;pairs&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;pairs&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;Pair&lt;/span&gt;{&lt;span style=&#34;color:#a6e22e&#34;&gt;Number&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;num&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;Count&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt;})&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 3. 使用 sort.Slice 进行自定义降序排序&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;sort&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Slice&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;pairs&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;pairs&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;].&lt;span style=&#34;color:#a6e22e&#34;&gt;Count&lt;/span&gt; &amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;pairs&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;].&lt;span style=&#34;color:#a6e22e&#34;&gt;Count&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    })&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 4. 取出前 k 个元素&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;result&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#a6e22e&#34;&gt;k&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;result&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;result&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;pairs&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;].&lt;span style=&#34;color:#a6e22e&#34;&gt;Number&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;result&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个解法的时间复杂度是 O(N log N)，瓶颈在于排序。虽然可行，但在面试中，面试官往往会追问：“还有没有更优的方法？”&lt;/p&gt;</description>
    </item>
    <item>
      <title>面试题-go语言基础</title>
      <link>https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E7%AF%87%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 01 Sep 2025 00:00:00 +0000</pubDate>
      <guid>https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E7%AF%87%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>&lt;h1 id=&#34;go-string-和-byte-的区别&#34;&gt;&#xD;&#xA;  Go string 和 []byte 的区别&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#go-string-%e5%92%8c-byte-%e7%9a%84%e5%8c%ba%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;如果需要频繁地修改字符串内容，或者处理⼆进制数据，使用&lt;code&gt;[]byte&lt;/code&gt;更为合适，如果字符串内容基本保持不变，并且主要处理⽂本数据，那么使⽤  &lt;code&gt;string&lt;/code&gt; 更为⽅便。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;不可变性&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;code&gt;string&lt;/code&gt;是不可变的数据类型，一旦创建就不能被修改。任何修改&lt;code&gt;string&lt;/code&gt;的操作都会产生一个新的&lt;code&gt;string&lt;/code&gt;，而原始的&lt;code&gt;string&lt;/code&gt;保持不变。相比之下，&lt;code&gt;[]byte&lt;/code&gt;是可变的切片，可以通过索引直接修改切片中的元素&lt;/p&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;类型转换&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;可以在&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;[]byte&lt;/code&gt;之间进行类型转换。使用&lt;code&gt;[]byte(s)&lt;/code&gt;可以将&lt;code&gt;string&lt;/code&gt;转换为&lt;code&gt;[]byte&lt;/code&gt;,而使用&lt;code&gt;string(b)&lt;/code&gt;可以将&lt;code&gt;[]byte&lt;/code&gt;转换为&lt;code&gt;string&lt;/code&gt;。这个操作会创建新的底层数组，因此在转换后修改其中一个不会影响另一个。&lt;/p&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;内存分配&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;string&lt;/code&gt;是一个不可变的视图，底层数据是只读的。&lt;code&gt;string&lt;/code&gt;的内存分配和释放由Go运行时管理。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;[]byte&lt;/code&gt;是一个可变的切片，底层数据是可以修改的。&lt;code&gt;[]byte&lt;/code&gt;的内存管理由程序员负责。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;Unicode字符&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;code&gt;string&lt;/code&gt;中的每个元素是一个Unicode字符，而&lt;code&gt;[]byte&lt;/code&gt;中的每个元素是一个字节。因此，&lt;code&gt;string&lt;/code&gt;可以包含任意字符，而&lt;code&gt;[]byte&lt;/code&gt;主要用于处理字节数据。&lt;/p&gt;&#xA;&lt;h1 id=&#34;make和new的区别&#34;&gt;&#xD;&#xA;  make和new的区别&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#make%e5%92%8cnew%e7%9a%84%e5%8c%ba%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;&lt;code&gt;make&lt;/code&gt;和&lt;code&gt;new&lt;/code&gt;是两个用于分配内存的内建函数，在使用场景和返回类型上有明显的区别&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;make&lt;/code&gt;用于创建并初始化切片、映射和通道等引用类型。它返回的是被初始化的**非零值（非nil）**的引用类型。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 创建并初始化切片&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;slice&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt;make([]&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 创建并初始化映射&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;myMap&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt;make(&lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 创建并初始化通道&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ch&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt;make(&lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;new&lt;/code&gt; ⽤于分配值类型的内存，并返回该值类型的指针。它返回的是分配的&lt;strong&gt;零值&lt;/strong&gt;的指针。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 分配整数类型的内存，并返回指针&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ptr&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt;new(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 使用make并初始化切片&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;slice&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt;make([]&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;slice&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 输出:[0 0 0 0 0]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 使用new分配整数类型的内存，并返回指针&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;ptr&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt;new(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ptr&lt;/span&gt;)&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;// 输出0&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;总结：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;new&lt;/code&gt;只⽤于分配内存，返回⼀个指向地址的指针。它为每个新类型分配⼀⽚内存，初始化为0且返回类型*T的内存地址，它相当于&amp;amp;T{}&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;make&lt;/code&gt;只可⽤于&lt;strong&gt;slice,map,channel&lt;/strong&gt;的初始化,返回的是&lt;strong&gt;引用&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;数组和切片的区别&#34;&gt;&#xD;&#xA;  数组和切片的区别&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e7%bb%84%e5%92%8c%e5%88%87%e7%89%87%e7%9a%84%e5%8c%ba%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;数组&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;固定⻓度，在声明数组时，需要指定数组的⻓度，且不能更改。&lt;/li&gt;&#xA;&lt;li&gt;值类型，当将⼀个数组赋值给另⼀个数组时，会进⾏值拷⻉。这意味着修改⼀个数组的副本不会影响原始数组。&lt;/li&gt;&#xA;&lt;li&gt;数组的元素在内存中是顺序存储的，分配在⼀块连续的内存区域&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;切片&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;切⽚的⻓度可以动态调整，⽽且可以不指定⻓度。&lt;/li&gt;&#xA;&lt;li&gt;切⽚是引⽤类型，当将⼀个切⽚赋值给另⼀个切⽚时，它们引⽤的是相同的底层数组。修改⼀个切⽚的元素会 影响到其他引⽤该底层数组的切⽚。&lt;/li&gt;&#xA;&lt;li&gt;切⽚本身不存储元素，⽽是引⽤⼀个底层数组。切⽚的底层数组会在需要时进⾏动态扩展。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 创建切⽚&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;slice1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make([]&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;)  &lt;span style=&#34;color:#75715e&#34;&gt;// ⻓度为3，容量为5的切⽚&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;slice2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;{&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;}     &lt;span style=&#34;color:#75715e&#34;&gt;// 直接初始化切⽚&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;slice3&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;arr1&lt;/span&gt;[:]            &lt;span style=&#34;color:#75715e&#34;&gt;// 从数组截取切⽚&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;切片是如何扩容的&#34;&gt;&#xD;&#xA;  切片是如何扩容的&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%87%e7%89%87%e6%98%af%e5%a6%82%e4%bd%95%e6%89%a9%e5%ae%b9%e7%9a%84&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;切⽚的扩容容量是按指数增⻓的。当切⽚的容量不⾜时，Go运⾏时系统会分配⼀个更⼤的底层数组，并将原来的元素拷⻉到新数组中。新数组的⼤⼩通常是原数组的两倍（但并不⼀定严格遵循2倍关系）&lt;/li&gt;&#xA;&lt;li&gt;在切⽚扩容时，Go运⾏时系统会预估未来的元素增⻓，并提前分配⾜够的空间。这可以减少频繁的内存分配和拷⻉操作。&lt;/li&gt;&#xA;&lt;li&gt;对于⼩切⽚，扩容时增加的容量可能相对较⼩，避免了内存的过度浪费。⽽对于⼤切⽚，扩容时增加的容量可能较多。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xD;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xD;&#xA;  &lt;p&gt;首先判断，如果新申请容量⼤于2倍的旧容量，最终容量就是新申请的容量&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
