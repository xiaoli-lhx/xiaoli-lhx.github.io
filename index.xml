<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog</title>
    <link>https://xiaoli-lhx.github.io/</link>
    <description>Recent content on Blog</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 01 Sep 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://xiaoli-lhx.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go语言基础</title>
      <link>https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 26 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E5%9F%BA%E7%A1%80/</guid>
      <description>&lt;h1 id=&#34;go语言基础&#34;&gt;&#xD;&#xA;  Go语言基础&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#go%e8%af%ad%e8%a8%80%e5%9f%ba%e7%a1%80&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;8.26 已完成：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; go的特点与优势&lt;/li&gt;&#xA;&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 包管理&lt;/li&gt;&#xA;&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 实现重载&lt;/li&gt;&#xA;&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 实现继承&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;TODO：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 实现多态&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 切片与数组区别&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; slice相关&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; struct与class&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 错误处理机制&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;1-和java对比介绍一下go语言的优势和特点&#34;&gt;&#xD;&#xA;  1. 和Java对比，介绍一下go语言的优势和特点&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%e5%92%8cjava%e5%af%b9%e6%af%94%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8bgo%e8%af%ad%e8%a8%80%e7%9a%84%e4%bc%98%e5%8a%bf%e5%92%8c%e7%89%b9%e7%82%b9&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;&lt;strong&gt;考点&lt;/strong&gt;：对编程语言的理解&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;难度&lt;/strong&gt;：简单&lt;/p&gt;&#xA;&lt;p&gt;总的来说，Go语言在性能、并发处理、部署和开发效率上都有其独特的优势，尤其适合网络服务和云计算领域&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;语法简洁：Go语言的语法非常简洁，没有类和继承等概念，代码易于维护和读写&lt;/li&gt;&#xA;&lt;li&gt;编译型语言：Go语言是一种编译型语言，编译成机器码直接运行，且编译速度很快&lt;/li&gt;&#xA;&lt;li&gt;高性能：Go语言的执行速度接近于C/C++，速度比Java快&lt;/li&gt;&#xA;&lt;li&gt;并发支持：Go语言的并发模型是基于&lt;code&gt;goroutine&lt;/code&gt;和&lt;code&gt;channel&lt;/code&gt;，使得并发编程变的简单高效，而Java的多线程模型相对较为复杂一些&lt;/li&gt;&#xA;&lt;li&gt;内存管理：Go语言拥有自己的垃圾回收机制，简化了内存管理&lt;/li&gt;&#xA;&lt;li&gt;部署简单：Go程序编译后生成单一的可执行文件，部署非常简单&lt;/li&gt;&#xA;&lt;li&gt;标准库丰富：Go拥有高质量的标准库，涵盖网络、加密、数据结构等方面&lt;/li&gt;&#xA;&lt;li&gt;工具链：Go有一套强大的工具链，如用于格式化代码的&lt;code&gt;gofmt&lt;/code&gt;、用于性能分析的&lt;code&gt;pprof&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;静态类型：Go是静态类型语言，有助于在编译时捕捉错误&lt;/li&gt;&#xA;&lt;li&gt;跨平台编译：Go支持跨平台编译，可以很方便地为不同操作系统构建应用程序&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;2-go包管理的方式有哪些&#34;&gt;&#xD;&#xA;  2. go包管理的方式有哪些？&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2-go%e5%8c%85%e7%ae%a1%e7%90%86%e7%9a%84%e6%96%b9%e5%bc%8f%e6%9c%89%e5%93%aa%e4%ba%9b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;&lt;strong&gt;考点&lt;/strong&gt;：包管理&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;难度&lt;/strong&gt;：简单&lt;/p&gt;&#xA;&lt;p&gt;Go语言的包管理最开始是&lt;code&gt;GOPATH&lt;/code&gt;的方式，每个项目都需要放在&lt;code&gt;GOPATH&lt;/code&gt;的下面，Go会从&lt;code&gt;GOPATH&lt;/code&gt;的&lt;code&gt;src&lt;/code&gt;目录寻找所有的包。&lt;/p&gt;&#xA;&lt;p&gt;现在主要用&lt;code&gt;Go Modules&lt;/code&gt;，官方从1.11版本开始引入，成了官方推荐的包管理方式。不再依赖&lt;code&gt;GOPATH&lt;/code&gt;,可以直接在任何地方创建项目，通过&lt;code&gt;go.mod&lt;/code&gt;文件来管理依赖。&lt;/p&gt;&#xA;&lt;h2 id=&#34;3-go支持重载吗如何在go中实现一个方法的重载&#34;&gt;&#xD;&#xA;  3. Go支持重载吗？如何在Go中实现一个方法的&amp;quot;重载&amp;quot;？&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#3-go%e6%94%af%e6%8c%81%e9%87%8d%e8%bd%bd%e5%90%97%e5%a6%82%e4%bd%95%e5%9c%a8go%e4%b8%ad%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e6%96%b9%e6%b3%95%e7%9a%84%e9%87%8d%e8%bd%bd&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;&lt;strong&gt;考点&lt;/strong&gt;：方法重载&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;难度&lt;/strong&gt;：中等&lt;/p&gt;&#xA;&lt;p&gt;Go 不支持函数/方法的重载，你&lt;strong&gt;不能在同一个作用域中定义多个函数名相同但参数不同的函数&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;会报编译错误：&lt;strong&gt;“（function name） redeclared in this block”&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;可以通过以下方式&lt;strong&gt;模拟&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用接口+类型断言&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Add&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt;{}) &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt;{} {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;switch&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;aVal&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;.(&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bVal&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;);&lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;aVal&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;bVal&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;float64&lt;/span&gt;:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bVal&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.(&lt;span style=&#34;color:#66d9ef&#34;&gt;float64&lt;/span&gt;);&lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;aVal&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;bVal&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;使用组合+接口&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;不同的方法封装在不同的嵌套结构中，外部选择性调用这些方法&lt;/p&gt;</description>
    </item>
    <item>
      <title>TCP/IP网络模型有哪几层？</title>
      <link>https://xiaoli-lhx.github.io/%E8%AE%A1%E7%BD%91/%E5%9F%BA%E7%A1%80%E7%AF%87/tcp_ip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E5%B1%82/</link>
      <pubDate>Sun, 24 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://xiaoli-lhx.github.io/%E8%AE%A1%E7%BD%91/%E5%9F%BA%E7%A1%80%E7%AF%87/tcp_ip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E5%B1%82/</guid>
      <description>&lt;h1 id=&#34;tcpip网络模型有哪几层&#34;&gt;&#xD;&#xA;  TCP/IP网络模型有哪几层？&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#tcpip%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b%e6%9c%89%e5%93%aa%e5%87%a0%e5%b1%82&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;1-应用层&#34;&gt;&#xD;&#xA;  1. 应用层&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%e5%ba%94%e7%94%a8%e5%b1%82&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;最上层的，也是我们能直接接触到的就是&lt;strong&gt;应用层&lt;/strong&gt;（&lt;em&gt;Application Layer&lt;/em&gt;）,应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。应用层是不用去关心数据是如何传输的,应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-传输层&#34;&gt;&#xD;&#xA;  2. 传输层&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2-%e4%bc%a0%e8%be%93%e5%b1%82&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;应用层的数据包会传给传输层，&lt;strong&gt;传输层&lt;/strong&gt;（&lt;em&gt;Transport Layer&lt;/em&gt;）是为应用层提供网络支持的。&lt;/p&gt;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;script src=&#34;https://xiaoli-lhx.github.io/mermaid.min.js&#34;&gt;&lt;/script&gt;&#xD;&#xA;&#xD;&#xA;  &lt;script&gt;mermaid.initialize({&#xD;&#xA;  &#34;flowchart&#34;: {&#xD;&#xA;    &#34;useMaxWidth&#34;:true&#xD;&#xA;  },&#xD;&#xA;  &#34;theme&#34;: &#34;default&#34;&#xD;&#xA;}&#xD;&#xA;)&lt;/script&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;pre class=&#34;mermaid&#34;&gt;flowchart BT&#xD;&#xA;    传输层--&amp;gt;应用层A&#xD;&#xA;&#x9;传输层--&amp;gt;应用层B&lt;/pre&gt;&#xD;&#xA;&lt;p&gt;在传输层会有两个传输协议，分别是 &lt;code&gt;TCP&lt;/code&gt;和&lt;code&gt; UDP&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;TCP 的全称叫传输控制协议,TCP比&lt;code&gt;UDP&lt;/code&gt;多了很多特性，比如流量控制，超时重传，拥塞控制等,这些都是为了保证数据包能可靠的传输给对方。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;UDP&lt;/code&gt;相对来说很简单，简单到只负责发送数据包，不保证数据包能抵达对方，但他的实时性相对更好，传输效率也高&lt;/p&gt;&#xA;&lt;p&gt;当传输层的数据包大小超过&lt;code&gt;MSS&lt;/code&gt;(TCP 最大报文段长度)，就需要将数据包分块，这样即使中途有一个分块丢失或者损坏，只需要重新发送这一个分块，而不需要发送整个数据包。在TCP协议中，我们把每个分块成为一个TCP段&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;端口&lt;/strong&gt;：当设备作为接收方时，传输层则要负责把数据包传给应用，但一台设备可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用去分开来，这个编号就是端口。&lt;/p&gt;&#xA;&lt;p&gt;由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。&lt;/p&gt;&#xA;&lt;h2 id=&#34;3-网络层&#34;&gt;&#xD;&#xA;  3. 网络层&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#3-%e7%bd%91%e7%bb%9c%e5%b1%82&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;pre class=&#34;mermaid&#34;&gt;flowchart BT&#xD;&#xA;    网络层--&amp;gt;传输层A--&amp;gt;应用层A&#xD;&#xA;&#x9;网络层--&amp;gt;传输层B--&amp;gt;应用层B&lt;/pre&gt;&#xD;&#xA;&lt;p&gt;网络层最常使用的时IP协议，IP协议会将传输层的报文作为数据部分，再加上IP报头组成IP报文，如果IP报文大小超过MTU（以太网中一般为1500字节）就会再次进行分片，得到一个即将发送到网络的IP报文。&lt;/p&gt;&#xA;&lt;p&gt;网络层负责将数据从一个设备传输到另一个设备。&lt;/p&gt;&#xA;&lt;p&gt;需要将 IP 地址分成两种意义：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个是&lt;strong&gt;网络号&lt;/strong&gt;，负责标识该 IP 地址是属于哪个「子网」的；&lt;/li&gt;&#xA;&lt;li&gt;一个是&lt;strong&gt;主机号&lt;/strong&gt;，负责标识同一「子网」下的不同主机；&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这需要配合&lt;strong&gt;子网掩码&lt;/strong&gt;才能算出 IP 地址 的网络号和主机号。&lt;/p&gt;&#xA;&lt;p&gt;将IP地址与子网掩码&lt;strong&gt;按位与运算&lt;/strong&gt;，就可以得到网络号。&lt;/p&gt;&#xA;&lt;p&gt;将子网掩码取反后与IP地址进行进行&lt;strong&gt;按位与运算&lt;/strong&gt;，就可以得到主机号。&lt;/p&gt;&#xA;&lt;p&gt;在寻址的过程中，先匹配到相同的网络号（表示要找到同一个子网），才会去找对应的主机。&lt;/p&gt;&#xA;&lt;p&gt;除了寻址能力， IP 协议还有另一个重要的能力就是&lt;strong&gt;路由&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。&lt;/p&gt;&#xA;&lt;p&gt;所以，IP协议的寻址作用是告诉我们去往下一个目的地该往哪个方向走，路由则是根据下一个目的地选择路径。寻址更像在导航，路由更像在操作方向盘。&lt;/p&gt;&#xA;&lt;h2 id=&#34;4-网络接口层&#34;&gt;&#xD;&#xA;  4. 网络接口层&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#4-%e7%bd%91%e7%bb%9c%e6%8e%a5%e5%8f%a3%e5%b1%82&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;生成了 IP 头部之后，接下来要交给网络接口层,在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。&lt;/p&gt;</description>
    </item>
    <item>
      <title>TCP篇</title>
      <link>https://xiaoli-lhx.github.io/%E8%AE%A1%E7%BD%91/tcp%E7%AF%87/tcp%E7%AF%87/</link>
      <pubDate>Sat, 23 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://xiaoli-lhx.github.io/%E8%AE%A1%E7%BD%91/tcp%E7%AF%87/tcp%E7%AF%87/</guid>
      <description>&lt;h1 id=&#34;udp与tcp协议&#34;&gt;&#xD;&#xA;  UDP与TCP协议&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#udp%e4%b8%8etcp%e5%8d%8f%e8%ae%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;udp协议&#34;&gt;&#xD;&#xA;  UDP协议&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#udp%e5%8d%8f%e8%ae%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;UDP（User Datagram Protocol，用户数据报协议）是一种无连接的传输层协议，它不保证数据可靠到达，也不保证数据顺序到达。它只提供一种简单的面向数据报的通信方式。&lt;/p&gt;</description>
    </item>
    <item>
      <title>在浏览器中输入URL并按下回车之和会发生什么</title>
      <link>https://xiaoli-lhx.github.io/%E8%AE%A1%E7%BD%91/%E5%9F%BA%E7%A1%80%E7%AF%87/url_about/</link>
      <pubDate>Mon, 01 Sep 2025 00:00:00 +0000</pubDate>
      <guid>https://xiaoli-lhx.github.io/%E8%AE%A1%E7%BD%91/%E5%9F%BA%E7%A1%80%E7%AF%87/url_about/</guid>
      <description>&lt;h1 id=&#34;在浏览器中输入url并按下回车之和会发生什么&#34;&gt;&#xD;&#xA;  在浏览器中输入URL并按下回车之和会发生什么&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9c%a8%e6%b5%8f%e8%a7%88%e5%99%a8%e4%b8%ad%e8%be%93%e5%85%a5url%e5%b9%b6%e6%8c%89%e4%b8%8b%e5%9b%9e%e8%bd%a6%e4%b9%8b%e5%92%8c%e4%bc%9a%e5%8f%91%e7%94%9f%e4%bb%80%e4%b9%88&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;1-输入url并解析&#34;&gt;&#xD;&#xA;  1. 输入URL并解析&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%e8%be%93%e5%85%a5url%e5%b9%b6%e8%a7%a3%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;输入&lt;code&gt;URL&lt;/code&gt;后，浏览器会解析出协议、主机、端口、路径等信息，并构造一个HTTP请求（浏览器会根据请求头判断是否有&lt;code&gt;HTTP缓存&lt;/code&gt;，并根据是否有缓存决定是从服务器获取资源还是使用缓存资源）&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-dns域名解析将域名解析成对应的ip地址&#34;&gt;&#xD;&#xA;  2. DNS域名解析，将域名解析成对应的IP地址&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2-dns%e5%9f%9f%e5%90%8d%e8%a7%a3%e6%9e%90%e5%b0%86%e5%9f%9f%e5%90%8d%e8%a7%a3%e6%9e%90%e6%88%90%e5%af%b9%e5%ba%94%e7%9a%84ip%e5%9c%b0%e5%9d%80&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;在发送HTTP请求之前，浏览器需要知道想要访问网页对应的IP地址，这就需要使用到&lt;code&gt;DNS域名解析&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;3-建立起tcp连接之三次握手&#34;&gt;&#xD;&#xA;  3. 建立起TCP连接之三次握手&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#3-%e5%bb%ba%e7%ab%8b%e8%b5%b7tcp%e8%bf%9e%e6%8e%a5%e4%b9%8b%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&#xD;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xD;&#xA;  &lt;p&gt;这里可以拓展很多，比如为什么是三次，不是两次、四次？如果第一次握手丢失了会发生什么？三次握手过程中可以携带数据吗？&lt;/p&gt;&#xD;&#xA;&lt;/blockquote&gt;&lt;p&gt;客户端和服务器之间进行HTTP请求和HTTP响应的过程中，需要建立起TCP连接，TCP连接需要进行三次握手&lt;/p&gt;&#xA;&lt;h2 id=&#34;4-浏览器发送httphttps请求到web服务器&#34;&gt;&#xD;&#xA;  4. 浏览器发送HTTP/HTTPS请求到web服务器&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#4-%e6%b5%8f%e8%a7%88%e5%99%a8%e5%8f%91%e9%80%81httphttps%e8%af%b7%e6%b1%82%e5%88%b0web%e6%9c%8d%e5%8a%a1%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&#xD;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xD;&#xA;  &lt;p&gt;扩展问题比如HTTP/HTTPS的区别？请求的方式？请求的状态码等和HTTP请求的问题&lt;/p&gt;&#xD;&#xA;&lt;/blockquote&gt;&lt;h2 id=&#34;5-服务器处理http请求并返回http报文&#34;&gt;&#xD;&#xA;  5. 服务器处理HTTP请求并返回HTTP报文&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#5-%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%a4%84%e7%90%86http%e8%af%b7%e6%b1%82%e5%b9%b6%e8%bf%94%e5%9b%9ehttp%e6%8a%a5%e6%96%87&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;服务器会接受请求并将其传递给请求处理程序并发送HTTP响应，一般响应报文包含：请求的网页以及状态码，压缩类型，如何缓存的页面，设置的cookie；&lt;/p&gt;&#xA;&lt;h2 id=&#34;6-浏览器渲染页面&#34;&gt;&#xD;&#xA;  6. 浏览器渲染页面&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#6-%e6%b5%8f%e8%a7%88%e5%99%a8%e6%b8%b2%e6%9f%93%e9%a1%b5%e9%9d%a2&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h2 id=&#34;7-断开连接之tcp四次挥手&#34;&gt;&#xD;&#xA;  7. 断开连接之TCP四次挥手&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#7-%e6%96%ad%e5%bc%80%e8%bf%9e%e6%8e%a5%e4%b9%8btcp%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&#xD;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xD;&#xA;  &lt;p&gt;四次挥手的过程，为什么是四次？&lt;/p&gt;&#xD;&#xA;&lt;/blockquote&gt;&lt;p&gt;客户端和服务器之间断开连接需要进行四次挥手&lt;/p&gt;&#xA;&lt;h1 id=&#34;dns&#34;&gt;&#xD;&#xA;  DNS&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#dns&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;</description>
    </item>
    <item>
      <title>Go语言中栈的实现：Slice还是List？</title>
      <link>https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%8B%9F%E6%A0%88/</link>
      <pubDate>Wed, 27 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%8B%9F%E6%A0%88/</guid>
      <description>&lt;h1 id=&#34;go语言中栈的实现slice还是list&#34;&gt;&#xD;&#xA;  Go语言中栈的实现：Slice还是List？&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#go%e8%af%ad%e8%a8%80%e4%b8%ad%e6%a0%88%e7%9a%84%e5%ae%9e%e7%8e%b0slice%e8%bf%98%e6%98%aflist&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;前言&#34;&gt;&#xD;&#xA;  前言&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%89%8d%e8%a8%80&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;在刷 LeetCode 题目「&#xD;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/&#34;&gt;LC1047. 删除字符串中的所有相邻重复项&lt;/a&gt;」时，我遇到了一个典型的栈应用场景。基于之前的学习，我首先使用 Go 的 &lt;code&gt;container/list&lt;/code&gt;（双向链表）来模拟栈，但发现执行效率并不理想。&#xA;&#xD;&#xA;  &lt;img src=&#34;https://xiaoli-lhx.github.io/images/go-stack.jpg&#34; alt=&#34;go-stack.jpg&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;在查阅了执行速度更快的解法后，我发现大家普遍使用 &lt;strong&gt;切片 (&lt;code&gt;slice&lt;/code&gt;)&lt;/strong&gt; 来模拟栈。这引发了我的思考：在 Go 语言中，实现栈时应该用 &lt;code&gt;container/list&lt;/code&gt; 还是切片？本文将探讨这两种方式的差异与优劣。&lt;/p&gt;&#xA;&lt;h2 id=&#34;两种实现方式的底层原理&#34;&gt;&#xD;&#xA;  两种实现方式的底层原理&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%a4%e7%a7%8d%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f%e7%9a%84%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;为了理解它们的差异，我们首先要了解两者在内存中的样子。&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-切片-slice---连续的盒子-&#34;&gt;&#xD;&#xA;  1. 切片 (Slice) - 连续的盒子 📦&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%e5%88%87%e7%89%87-slice---%e8%bf%9e%e7%bb%ad%e7%9a%84%e7%9b%92%e5%ad%90-&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;&lt;strong&gt;切片 (&lt;code&gt;slice&lt;/code&gt;)&lt;/strong&gt; 的本质是一个&lt;strong&gt;动态数组&lt;/strong&gt;，它的数据存放在一块&lt;strong&gt;连续的内存&lt;/strong&gt;中。就像一个有格子的长条盒子，所有元素都紧密地挨在一起。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// --- 用切片实现栈 ---&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt; = []&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;{}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 入栈&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 出栈&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt;[:len(&lt;span style=&#34;color:#a6e22e&#34;&gt;stack&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;2-containerlist---分散的车厢-&#34;&gt;&#xD;&#xA;  2. container/list - 分散的车厢 🚂&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#2-containerlist---%e5%88%86%e6%95%a3%e7%9a%84%e8%bd%a6%e5%8e%a2-&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;&lt;strong&gt;&lt;code&gt;container/list&lt;/code&gt;&lt;/strong&gt; 的本质是一个&lt;strong&gt;双向链表&lt;/strong&gt;。它的每个元素（节点）都是一个独立的对象，存放在内存中可能不连续的位置，通过指针相互连接。就像一串火车车厢，每个车厢都知道它的前后车厢是谁。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// --- 用 list 实现栈 ---&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;stackList&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;list&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;New&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 入栈&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;stackList&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;PushBack&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 出栈&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;stackList&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Remove&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;stackList&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Back&lt;/span&gt;())&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;核心对比性能与简洁度&#34;&gt;&#xD;&#xA;  核心对比：性能与简洁度&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%b8%e5%bf%83%e5%af%b9%e6%af%94%e6%80%a7%e8%83%bd%e4%b8%8e%e7%ae%80%e6%b4%81%e5%ba%a6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;性能对比为何切片通常更快&#34;&gt;&#xD;&#xA;  性能对比：为何切片通常更快？&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%80%a7%e8%83%bd%e5%af%b9%e6%af%94%e4%b8%ba%e4%bd%95%e5%88%87%e7%89%87%e9%80%9a%e5%b8%b8%e6%9b%b4%e5%bf%ab&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;理论上，两种方式的入栈和出栈操作时间复杂度都是 O(1)。但在实际运行中，&lt;strong&gt;切片通常性能更好&lt;/strong&gt;，这主要得益于“&lt;strong&gt;内存局部性&lt;/strong&gt;”（Memory Locality）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 语言解「前 K 个高频元素」：从排序到堆的深度探索</title>
      <link>https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E8%AF%AD%E8%A8%80%E5%A0%86/</link>
      <pubDate>Sun, 31 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/go%E8%AF%AD%E8%A8%80%E5%A0%86/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;&#xD;&#xA;  前言&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%89%8d%e8%a8%80&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;最近在刷 LeetCode 时，遇到了一道非常经典的题目：「&#xD;&#xA;  &lt;a href=&#34;https://leetcode.cn/problems/top-k-frequent-elements/&#34;&gt;347. 前 K 个高频元素&lt;/a&gt;」。这道题不仅考察了基本的数据处理能力，更引出了一些关于排序和更高级数据结构的深度思考。&lt;/p&gt;&#xA;&lt;p&gt;我的第一反应是，这需要分两步走：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;统计每个元素出现的频率。&lt;/li&gt;&#xA;&lt;li&gt;找出频率最高的 k 个元素。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;第一步用哈希表（&lt;code&gt;map&lt;/code&gt;）解决非常直观，但第二步“如何找出最高频的k个”则引出了几种不同的实现方式和性能考量。这篇博客记录了我从最直观的“排序”解法，到更高效的“堆”解法的完整思考过程。&lt;/p&gt;&#xA;&lt;h2 id=&#34;思路一哈希表--排序-直观解法&#34;&gt;&#xD;&#xA;  思路一：哈希表 + 排序 (直观解法)&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%80%9d%e8%b7%af%e4%b8%80%e5%93%88%e5%b8%8c%e8%a1%a8--%e6%8e%92%e5%ba%8f-%e7%9b%b4%e8%a7%82%e8%a7%a3%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;这是我最先想到的方法，思路清晰，容易理解。&lt;/p&gt;&#xA;&lt;h3 id=&#34;核心思路&#34;&gt;&#xD;&#xA;  核心思路&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%b8%e5%bf%83%e6%80%9d%e8%b7%af&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;统计频率&lt;/strong&gt;：遍历一遍数组，用一个 &lt;code&gt;map[int]int&lt;/code&gt; 来存储每个数字及其出现的次数。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;转换结构&lt;/strong&gt;：将 &lt;code&gt;map&lt;/code&gt; 中的键值对转换到一个结构体切片中，每个结构体包含 &lt;code&gt;Number&lt;/code&gt; 和 &lt;code&gt;Count&lt;/code&gt; 两个字段。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;排序&lt;/strong&gt;：对该切片按照 &lt;code&gt;Count&lt;/code&gt; 字段进行&lt;strong&gt;降序&lt;/strong&gt;排序。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;取值&lt;/strong&gt;：取出排序后切片的前 &lt;code&gt;k&lt;/code&gt; 个元素，即为所求。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;实现难点go-的自定义排序-sortslice&#34;&gt;&#xD;&#xA;  实现难点：Go 的自定义排序 &lt;code&gt;sort.Slice&lt;/code&gt;&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%9e%e7%8e%b0%e9%9a%be%e7%82%b9go-%e7%9a%84%e8%87%aa%e5%ae%9a%e4%b9%89%e6%8e%92%e5%ba%8f-sortslice&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;在第三步中，我们需要对一个自定义的结构体切片进行排序。Go 的 &lt;code&gt;sort&lt;/code&gt; 包提供了一个非常强大的函数 &lt;code&gt;sort.Slice&lt;/code&gt;，它允许我们提供一个自定义的“比较函数”来定义排序规则。&lt;/p&gt;&#xA;&lt;p&gt;对于降序排序，我们的规则是：&lt;strong&gt;如果元素 i 的次数大于元素 j 的次数，那么 i 就应该排在 j 的前面&lt;/strong&gt;。这个规则就通过&lt;code&gt;Less&lt;/code&gt;函数告诉&lt;code&gt;sort.Slice&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;go-代码实现&#34;&gt;&#xD;&#xA;  Go 代码实现&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#go-%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sort&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;topKFrequent_Sort&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;nums&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;k&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 1. 统计频率&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;freqMap&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make(&lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;num&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;nums&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;freqMap&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;num&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 2. 将 map 转换为 struct 切片&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Pair&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;Number&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;Count&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;pairs&lt;/span&gt; []&lt;span style=&#34;color:#a6e22e&#34;&gt;Pair&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;num&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;freqMap&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;pairs&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;pairs&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;Pair&lt;/span&gt;{&lt;span style=&#34;color:#a6e22e&#34;&gt;Number&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;num&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;Count&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt;})&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 3. 使用 sort.Slice 进行自定义降序排序&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;sort&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Slice&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;pairs&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;pairs&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;].&lt;span style=&#34;color:#a6e22e&#34;&gt;Count&lt;/span&gt; &amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;pairs&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;].&lt;span style=&#34;color:#a6e22e&#34;&gt;Count&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    })&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 4. 取出前 k 个元素&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;result&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#a6e22e&#34;&gt;k&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;result&lt;/span&gt; = append(&lt;span style=&#34;color:#a6e22e&#34;&gt;result&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;pairs&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;].&lt;span style=&#34;color:#a6e22e&#34;&gt;Number&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;result&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个解法的时间复杂度是 O(N log N)，瓶颈在于排序。虽然可行，但在面试中，面试官往往会追问：“还有没有更优的方法？”&lt;/p&gt;</description>
    </item>
    <item>
      <title>面试题-go语言基础</title>
      <link>https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E7%AF%87%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 01 Sep 2025 00:00:00 +0000</pubDate>
      <guid>https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E7%AF%87%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>&lt;h1 id=&#34;go-string-和-byte-的区别&#34;&gt;&#xD;&#xA;  Go string 和 []byte 的区别&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#go-string-%e5%92%8c-byte-%e7%9a%84%e5%8c%ba%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;如果需要频繁地修改字符串内容，或者处理⼆进制数据，使用&lt;code&gt;[]byte&lt;/code&gt;更为合适，如果字符串内容基本保持不变，并且主要处理⽂本数据，那么使⽤  &lt;code&gt;string&lt;/code&gt; 更为⽅便。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;不可变性&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;code&gt;string&lt;/code&gt;是不可变的数据类型，一旦创建就不能被修改。任何修改&lt;code&gt;string&lt;/code&gt;的操作都会产生一个新的&lt;code&gt;string&lt;/code&gt;，而原始的&lt;code&gt;string&lt;/code&gt;保持不变。相比之下，&lt;code&gt;[]byte&lt;/code&gt;是可变的切片，可以通过索引直接修改切片中的元素&lt;/p&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;类型转换&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;可以在&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;[]byte&lt;/code&gt;之间进行类型转换。使用&lt;code&gt;[]byte(s)&lt;/code&gt;可以将&lt;code&gt;string&lt;/code&gt;转换为&lt;code&gt;[]byte&lt;/code&gt;,而使用&lt;code&gt;string(b)&lt;/code&gt;可以将&lt;code&gt;[]byte&lt;/code&gt;转换为&lt;code&gt;string&lt;/code&gt;。这个操作会创建新的底层数组，因此在转换后修改其中一个不会影响另一个。&lt;/p&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;内存分配&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;string&lt;/code&gt;是一个不可变的视图，底层数据是只读的。&lt;code&gt;string&lt;/code&gt;的内存分配和释放由Go运行时管理。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;[]byte&lt;/code&gt;是一个可变的切片，底层数据是可以修改的。&lt;code&gt;[]byte&lt;/code&gt;的内存管理由程序员负责。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;Unicode字符&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;code&gt;string&lt;/code&gt;中的每个元素是一个Unicode字符，而&lt;code&gt;[]byte&lt;/code&gt;中的每个元素是一个字节。因此，&lt;code&gt;string&lt;/code&gt;可以包含任意字符，而&lt;code&gt;[]byte&lt;/code&gt;主要用于处理字节数据。&lt;/p&gt;&#xA;&lt;h1 id=&#34;make和new的区别&#34;&gt;&#xD;&#xA;  make和new的区别&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#make%e5%92%8cnew%e7%9a%84%e5%8c%ba%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;&lt;code&gt;make&lt;/code&gt;和&lt;code&gt;new&lt;/code&gt;是两个用于分配内存的内建函数，在使用场景和返回类型上有明显的区别&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;make&lt;/code&gt;用于创建并初始化切片、映射和通道等引用类型。它返回的是被初始化的**非零值（非nil）**的引用类型。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 创建并初始化切片&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;slice&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt;make([]&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 创建并初始化映射&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;myMap&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt;make(&lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 创建并初始化通道&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ch&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt;make(&lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;new&lt;/code&gt; ⽤于分配值类型的内存，并返回该值类型的指针。它返回的是分配的&lt;strong&gt;零值&lt;/strong&gt;的指针。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 分配整数类型的内存，并返回指针&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ptr&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt;new(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 使用make并初始化切片&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;slice&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt;make([]&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;slice&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// 输出:[0 0 0 0 0]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 使用new分配整数类型的内存，并返回指针&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;ptr&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt;new(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ptr&lt;/span&gt;)&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;// 输出0&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;总结：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;new&lt;/code&gt;只⽤于分配内存，返回⼀个指向地址的指针。它为每个新类型分配⼀⽚内存，初始化为0且返回类型*T的内存地址，它相当于&amp;amp;T{}&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;make&lt;/code&gt;只可⽤于&lt;strong&gt;slice,map,channel&lt;/strong&gt;的初始化,返回的是&lt;strong&gt;引用&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;数组和切片的区别&#34;&gt;&#xD;&#xA;  数组和切片的区别&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e7%bb%84%e5%92%8c%e5%88%87%e7%89%87%e7%9a%84%e5%8c%ba%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;数组&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;固定⻓度，在声明数组时，需要指定数组的⻓度，且不能更改。&lt;/li&gt;&#xA;&lt;li&gt;值类型，当将⼀个数组赋值给另⼀个数组时，会进⾏值拷⻉。这意味着修改⼀个数组的副本不会影响原始数组。&lt;/li&gt;&#xA;&lt;li&gt;数组的元素在内存中是顺序存储的，分配在⼀块连续的内存区域&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;切片&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;切⽚的⻓度可以动态调整，⽽且可以不指定⻓度。&lt;/li&gt;&#xA;&lt;li&gt;切⽚是引⽤类型，当将⼀个切⽚赋值给另⼀个切⽚时，它们引⽤的是相同的底层数组。修改⼀个切⽚的元素会 影响到其他引⽤该底层数组的切⽚。&lt;/li&gt;&#xA;&lt;li&gt;切⽚本身不存储元素，⽽是引⽤⼀个底层数组。切⽚的底层数组会在需要时进⾏动态扩展。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 创建切⽚&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;slice1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make([]&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;)  &lt;span style=&#34;color:#75715e&#34;&gt;// ⻓度为3，容量为5的切⽚&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;slice2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;{&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;}     &lt;span style=&#34;color:#75715e&#34;&gt;// 直接初始化切⽚&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;slice3&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;arr1&lt;/span&gt;[:]            &lt;span style=&#34;color:#75715e&#34;&gt;// 从数组截取切⽚&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;切片是如何扩容的&#34;&gt;&#xD;&#xA;  切片是如何扩容的&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%87%e7%89%87%e6%98%af%e5%a6%82%e4%bd%95%e6%89%a9%e5%ae%b9%e7%9a%84&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;切⽚的扩容容量是按指数增⻓的。当切⽚的容量不⾜时，Go运⾏时系统会分配⼀个更⼤的底层数组，并将原来的元素拷⻉到新数组中。新数组的⼤⼩通常是原数组的两倍（但并不⼀定严格遵循2倍关系）&lt;/li&gt;&#xA;&lt;li&gt;在切⽚扩容时，Go运⾏时系统会预估未来的元素增⻓，并提前分配⾜够的空间。这可以减少频繁的内存分配和拷⻉操作。&lt;/li&gt;&#xA;&lt;li&gt;对于⼩切⽚，扩容时增加的容量可能相对较⼩，避免了内存的过度浪费。⽽对于⼤切⽚，扩容时增加的容量可能较多。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xD;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xD;&#xA;  &lt;p&gt;首先判断，如果新申请容量⼤于2倍的旧容量，最终容量就是新申请的容量&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
