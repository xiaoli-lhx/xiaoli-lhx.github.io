<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DFS on Blog</title>
    <link>https://xiaoli-lhx.github.io/tags/dfs/</link>
    <description>Recent content in DFS on Blog</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 05 Oct 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://xiaoli-lhx.github.io/tags/dfs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>DFS vs BFS：算法世界的“深度”与“广度”，你该如何抉择？</title>
      <link>https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/bfs%E5%92%8Cdfs/</link>
      <pubDate>Sun, 05 Oct 2025 00:00:00 +0000</pubDate>
      <guid>https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/bfs%E5%92%8Cdfs/</guid>
      <description>&lt;h1 id=&#34;dfs-vs-bfs算法世界的深度与广度你该如何抉择&#34;&gt;&#xD;&#xA;  DFS vs BFS：算法世界的“深度”与“广度”，你该如何抉择？&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#dfs-vs-bfs%e7%ae%97%e6%b3%95%e4%b8%96%e7%95%8c%e7%9a%84%e6%b7%b1%e5%ba%a6%e4%b8%8e%e5%b9%bf%e5%ba%a6%e4%bd%a0%e8%af%a5%e5%a6%82%e4%bd%95%e6%8a%89%e6%8b%a9&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;引言&#34;&gt;&#xD;&#xA;  引言&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%95%e8%a8%80&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;在算法的江湖里，DFS 和 BFS 如同两位性格迥异的绝世高手。他们师出同门——都属于图（或树）的遍历算法，但招式却大相径庭。DFS（深度优先搜索）是一位探索家，不撞南墙不回头；而 BFS（广度优先搜索）则像一位指挥官，稳扎稳打，层层推进。&lt;/p&gt;&#xA;&lt;p&gt;很多初学者（包括我当初）常常会疑惑：什么时候该请出“探索家”DFS，什么时候又该派出“指挥官”BFS 呢？&lt;/p&gt;&#xA;&lt;p&gt;别担心，这篇博客将通过生动的比喻、清晰的图解和实战代码，带你彻底搞懂它们，让你在未来的算法之路上，面对任何遍历问题都能胸有成竹。&lt;/p&gt;&#xA;&lt;h2 id=&#34;什么是深度优先搜索-dfs---一条路走到黑的探索家&#34;&gt;&#xD;&#xA;  什么是深度优先搜索 (DFS)? - “一条路走到黑”的探索家&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e6%b7%b1%e5%ba%a6%e4%bc%98%e5%85%88%e6%90%9c%e7%b4%a2-dfs---%e4%b8%80%e6%9d%a1%e8%b7%af%e8%b5%b0%e5%88%b0%e9%bb%91%e7%9a%84%e6%8e%a2%e7%b4%a2%e5%ae%b6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;DFS 的核心思想非常符合人类的直觉：&lt;strong&gt;一条路走到黑&lt;/strong&gt;。想象一下你在走一个巨大的迷宫，为了找到出口，你决定采用以下策略：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;随便选一条没走过的岔路。&lt;/li&gt;&#xA;&lt;li&gt;沿着这条路一直走下去，直到遇到死胡同或者回到已经走过的路口。&lt;/li&gt;&#xA;&lt;li&gt;这时，退回到上一个岔路口，再选一条你没试过的路继续探索。&lt;/li&gt;&#xA;&lt;li&gt;重复以上步骤，直到找到出口或者所有路都试完。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;这就是 DFS！它会尽可能深地探索一个分支，然后再回溯。&lt;/p&gt;&#xA;&lt;h3 id=&#34;动画图解&#34;&gt;&#xD;&#xA;  动画图解&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8a%a8%e7%94%bb%e5%9b%be%e8%a7%a3&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;假设我们有下面这张图，从节点 A 开始，DFS 的探索路径可能是这样的：&lt;/p&gt;&#xA;&lt;p&gt;&#xD;&#xA;  &lt;img src=&#34;https://xiaoli-lhx.github.io/images/graph.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;&#xD;&#xA;  &lt;img src=&#34;https://xiaoli-lhx.github.io/images/DFS.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;可能的访问顺序：A -&amp;gt; B -&amp;gt; D -&amp;gt; E -&amp;gt; C -&amp;gt; F&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;核心数据结构&#34;&gt;&#xD;&#xA;  核心数据结构&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%b8%e5%bf%83%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;DFS 依赖于 &lt;strong&gt;栈 (Stack)&lt;/strong&gt; 的思想。当我们用 &lt;strong&gt;递归 (Recursion)&lt;/strong&gt; 来实现 DFS 时，其实就是巧妙地利用了程序的调用栈。&lt;/p&gt;&#xA;&lt;h3 id=&#34;go-代码模板-递归&#34;&gt;&#xD;&#xA;  Go 代码模板 (递归)&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#go-%e4%bb%a3%e7%a0%81%e6%a8%a1%e6%9d%bf-%e9%80%92%e5%bd%92&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// visited 用来记录访问过的节点，防止死循环&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;visited&lt;/span&gt; = make(&lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dfs&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 终止条件 (根据题目定义)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 标记已访问&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;visited&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;] = &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 处理当前节点逻辑 (例如：打印)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Value&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 递归访问邻居&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;neighbor&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Neighbors&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; !&lt;span style=&#34;color:#a6e22e&#34;&gt;visited&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;neighbor&lt;/span&gt;] {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;dfs&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;neighbor&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;&#xA;&lt;h2 id=&#34;什么是广度优先搜索-bfs---稳扎稳打的辐射源&#34;&gt;&#xD;&#xA;  什么是广度优先搜索 (BFS)? - “稳扎稳打”的辐射源&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e5%b9%bf%e5%ba%a6%e4%bc%98%e5%85%88%e6%90%9c%e7%b4%a2-bfs---%e7%a8%b3%e6%89%8e%e7%a8%b3%e6%89%93%e7%9a%84%e8%be%90%e5%b0%84%e6%ba%90&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;BFS 则完全不同，它的策略是 &lt;strong&gt;层层推进&lt;/strong&gt;。想象一下在平静的湖面投下一颗石子，水波纹是如何扩散的？它会先触及最近的一圈，再扩散到稍远的一圈，一圈一圈，非常规律。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
