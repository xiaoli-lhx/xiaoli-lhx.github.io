<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>动态规划 on Blog</title>
    <link>https://xiaoli-lhx.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
    <description>Recent content in 动态规划 on Blog</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 14 Oct 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://xiaoli-lhx.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>背包问题</title>
      <link>https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 14 Oct 2025 00:00:00 +0000</pubDate>
      <guid>https://xiaoli-lhx.github.io/go%E8%AF%AD%E8%A8%80/go%E5%9F%BA%E7%A1%80/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;h2 id=&#34;背包问题终极攻略一文学会所有变种go语言实现&#34;&gt;&#xD;&#xA;  背包问题终极攻略：一文学会所有变种（Go语言实现）&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%83%8c%e5%8c%85%e9%97%ae%e9%a2%98%e7%bb%88%e6%9e%81%e6%94%bb%e7%95%a5%e4%b8%80%e6%96%87%e5%ad%a6%e4%bc%9a%e6%89%80%e6%9c%89%e5%8f%98%e7%a7%8dgo%e8%af%ad%e8%a8%80%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;在动态规划的宏伟殿堂中，背包问题无疑是看门人，也是最经典的试金石。它形态多变，时而求最大价值，时而求方案总数；时而物品只能用一次，时而又能无限取用。&lt;/p&gt;&#xA;&lt;p&gt;许多初学者（甚至是有经验的开发者）在面对这些变种时，常常会混淆递推公式和循环顺序，导致“感觉会了，一写就错”。&lt;/p&gt;&#xA;&lt;p&gt;别担心，这篇文章将彻底终结你的烦恼。我们将通过&lt;strong&gt;三个核心维度&lt;/strong&gt;，为你建立一个清晰的思考框架，让你能够轻松识别并解决几乎所有的背包问题。所有代码都将以 &lt;strong&gt;Go 语言&lt;/strong&gt; 和&lt;strong&gt;一维 DP 空间优化&lt;/strong&gt;的形式呈现。&lt;/p&gt;&#xA;&lt;h3 id=&#34;三个核心维度解锁所有背包问题&#34;&gt;&#xD;&#xA;  三个核心维度，解锁所有背包问题&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%89%e4%b8%aa%e6%a0%b8%e5%bf%83%e7%bb%b4%e5%ba%a6%e8%a7%a3%e9%94%81%e6%89%80%e6%9c%89%e8%83%8c%e5%8c%85%e9%97%ae%e9%a2%98&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;忘掉那些死记硬背的模板吧！所有背包问题的变化，都可以归结为这三个维度的不同组合：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;目标不同 (求价值 vs 求方法数)&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;求最大价值&lt;/strong&gt;：核心是做选择，递推公式通常是 &lt;code&gt;max()&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;求方案总数&lt;/strong&gt;：核心是累加所有可能性，递推公式通常是 &lt;code&gt;+=&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;物品使用次数不同 (0/1 vs 完全背包)&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;0/1 背包&lt;/strong&gt; (每种物品最多用1次)：内层循环（遍历容量）必须&lt;strong&gt;倒序&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;完全背包&lt;/strong&gt; (每种物品可用无限次)：内层循环（遍历容量）必须&lt;strong&gt;正序&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;方案是否考虑顺序 (组合 vs 排列)&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;求组合&lt;/strong&gt; (顺序无关，&lt;code&gt;{1,2}&lt;/code&gt; 和 &lt;code&gt;{2,1}&lt;/code&gt; 算一种)：外层循环遍历&lt;strong&gt;物品&lt;/strong&gt;，内层循环遍历&lt;strong&gt;容量&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;求排列&lt;/strong&gt; (顺序相关，&lt;code&gt;{1,2}&lt;/code&gt; 和 &lt;code&gt;{2,1}&lt;/code&gt; 算两种)：外层循环遍历&lt;strong&gt;容量&lt;/strong&gt;，内层循环遍历&lt;strong&gt;物品&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;接下来，我们将用经典的例子来逐一解析这些维度组合出的题型。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;一求最大价值&#34;&gt;&#xD;&#xA;  一、求最大价值&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%80%e6%b1%82%e6%9c%80%e5%a4%a7%e4%bb%b7%e5%80%bc&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;这是背包问题最常见的形态，我们的目标是在有限的容量内，让装入的物品价值最大化。&lt;/p&gt;&#xA;&lt;h4 id=&#34;1-经典01背包求最大价值&#34;&gt;&#xD;&#xA;  1. 经典0/1背包：求最大价值&#xD;&#xA;  &#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#1-%e7%bb%8f%e5%85%b801%e8%83%8c%e5%8c%85%e6%b1%82%e6%9c%80%e5%a4%a7%e4%bb%b7%e5%80%bc&#34;&gt;#&lt;/a&gt;&#xD;&#xA;  &#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&#xD;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xD;&#xA;  &lt;p&gt;问题特征：每个物品最多只能选择一次，求能获得的最大总价值。&lt;/p&gt;&#xA;&lt;p&gt;核心维度：求最大价值 + 0/1背包&lt;/p&gt;&#xA;&lt;p&gt;实现要点：max() + 倒序内循环&lt;/p&gt;&#xD;&#xA;&lt;/blockquote&gt;&lt;p&gt;💡 为什么内循环要倒序？&lt;/p&gt;&#xA;&lt;p&gt;为了保证每个物品只被选择一次。在更新 dp[j] 时，我们需要 dp[j-weight[i]] 是上一轮（即不包含物品 i）的状态。倒序遍历时，当我们计算 dp[j]，dp[j-weight[i]] 尚未被本轮更新，仍是旧值，符合0/1定义。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
